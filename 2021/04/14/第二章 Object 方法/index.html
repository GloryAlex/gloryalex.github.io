<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=0"><meta name="description" content="二. Object 方法 [ A-Grain-Of-Sands ] "><meta name="theme-color" content="#ebc65a"><title>二. Object 方法 [ A-Grain-Of-Sands ] </title><style>@font-face {
  font-family: 'Abril Fatface';
  font-style: normal;
  font-weight: 400;
  src: local('Abril Fatface'), local('AbrilFatface-Regular'), url(data:font/woff2;base64,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) format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Abril Fatface';
  font-style: normal;
  font-weight: 400;
  src: local('Abril Fatface'), local('AbrilFatface-Regular'), url(data:font/woff2;base64,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BL3+M1K+NfPvjlJEHZTOrkYvtdprqx0Hka+W/IhsQoUJE0jsPVOhV2itgp3Wame8dsB73DeCOfp+FMSxp2At3aozP1zVQ/tmEpXdveum7kat3CaLXRcmTZHmOveMiqxSteCZOrGKmscOa9WycTUXtRFabrtts1Nb3e5qHtqWPMWtuEkMSdydcarhKoTcVXtBgujKwULbPFJvqywIzBjboUacECG6ajlIews5dBUMkJ/LYHa12gpRLEsBDAAA6raxOaTnbx4GG5J6hdn4twxT1DRvEQZvD6banOa3BbstVh48efHmw5cffwECBQkWIvK/LTbhIkSKEi1GrDjxEiRKkixFqjTpMmTKki1Hrjz5ChQqUqxEqTLlKlSqUq2e+hpoqJHGmmiqmeZhWGKoYfaZ7qXhxhtjnlWWxsBotw0xxWdfjDPDSEfc98l8q33z1XeLrXPKCeu10NJErZzR2kmnXXDWOee90sYVF12yQVsfTXLdVde088Y7o3TQXkedddLFQnb/qVGrq24cuuvhtZ5666WPfvraaZEB+htokLfe2+1GBDbalARuuueWzbbYboejttrmmBHW2O+AvUmRDMb6EEUsHHQoDskRjxRIiVRILev2qn1oaGpomZOB2z/jmn/eUk6tvaZda/5znbhPCguQ7wsEvd1strBI3OYR8ye01+ZO0jbH36oqKm37w90hl2v/wO5o3vIjtpoZx20H) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
</style><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><script src="https://cdn.bootcss.com/highlight.js/9.6.0/highlight.min.js" defer></script><script src="/js/paper.js" defer></script><script src="https://www.googletagmanager.com/gtag/js?id=xx-xxxxxxx-xx" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'xx-xxxxxxx-xx');</script><link rel="stylesheet" href="/css/tocbot.css"><script src="/js/tocbot.js" defer></script><script>window.addEventListener('DOMContentLoaded', () => {
  tocbot.init({
    // Where to render the table of contents.
    tocSelector: '.toc__content',
    // Where to grab the headings to build the table of contents.
    contentSelector: '.article__content',
    // Which headings to grab inside of the contentSelector element.
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    // For headings inside relative or absolute positioned containers within content.
    hasInnerContainers: true,
    orderedList: false,
    collapseDepth: 2,
  });
})</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
  }
});
MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
  }
});</script><link rel="preload" href="https://cdn.bootcss.com/highlight.js/9.6.0/styles/github.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.6.0/styles/github.min.css"><link rel="preload" href="https://fonts.googleapis.com/css?family=Abril+Fatface&amp;display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface&amp;display=swap"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="A-Grain-Of-Sands" type="application/atom+xml">
</head><body><div class="mask-border"></div><div class="head"><div class="head__inner"><h1><a href="/">A-Grain-Of-Sands</a></h1><p>a little site, a few techies</p></div></div><div class="paper-container"><div class="main"><div class="location-bar"><div class="line-1"><div class="horizontal-line" style="height: 3px"></div></div><div class="line-2"><div class="horizontal-line" style="height: 1px"></div></div><p class="text">二. Object 方法</p><div class="switch-button"><input class="container_toggle" type="checkbox" id="switch" name="mode"><label for="switch">Toggle</label></div><div class="line-3"><div class="horizontal-line" style="height: 1px"></div></div></div><div class="main__2-col"><article class="post-view__article"><div class="article__infomation"><div class="posts-item"><h2 class="posts-item__title"><a href="">二. Object 方法</a></h2><span class="post__date">2021-04-14</span><a href="/tags/EffectiveJava/"><span class="post__tags">#EffectiveJava</span></a><a href="/tags/Java/"><span class="post__tags">#Java</span></a></div></div><div class="article__content"><blockquote>
<p>本文是我的 <em>Effective Java 3rd Edition</em> 读书笔记。本书翻译较差，建议阅读英文版。</p>
</blockquote>
<p>本章节阐述对于所有对象都通用的那些方法，比如<code>equals</code>, <code>hashCode</code>和<code>clone</code>等方法所需要注意的事项。<br><span id="more"></span></p>
<h2 id="10-覆盖-equals-方法"><a href="#10-覆盖-equals-方法" class="headerlink" title="10. 覆盖 equals 方法"></a>10. 覆盖 equals 方法</h2><p>覆盖<code>equals</code>方法并不是必需的，而且错误的覆盖会导致许多问题，所以如果可以不用覆盖最好不要覆盖。以下是一些不用覆盖的情况：</p>
<ul>
<li>类的实例是唯一的。很多类代表实体而非值，比如<code>Thread</code>类。这些类使用<code>Object.equals</code>方法就足矣了。</li>
<li>类不必提供<strong>逻辑相等</strong>的能力。比如说<code>regex.Pattern</code>类。它有什么必要设置自己的<code>equals</code>方法呢？</li>
<li>父类已经覆盖过<code>equals</code>方法了，而且父类的行为在子类上也是合适的。例如 Java 的大部分集合类的实现，像<code>List</code>就使用的是继承自<code>AbstractList</code>的<code>equals</code>方法。</li>
<li>类是<code>private</code>或<code>package-private</code>的，而且它的<code>equals</code>永远也不会被调用。这种情况下你也可以覆盖<code>equals</code>方法以确保它一定不会被调用，像这样：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span></span>&#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError(); <span class="hljs-comment">//method is never called</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>那么，什么时候应该覆盖<code>equals</code>方法呢？当这个类有自己特有的<strong>逻辑相等</strong>的概念，并且其父类并没有提供这种行为的时候。典型的例子就是 value class类。覆盖了<code>equals</code>方法后，这个类的实例就能被用作字典的键，或者集合的元素。<br>要覆盖<code>equals</code>方法，必须遵守以下规定：</p>
<ol>
<li>自反性。即，对任意非 null 的引用 x, x.equals(x) 必须返回 true</li>
<li>对称性。即，对于任意非 null 的引用 x 和 y, 当且仅当 y.equals(x) 为 true 时，x.equals(y) 必须返回 true</li>
<li>传递性。对于任意非 null 的 x, y 和 z, 若 x.equals(y) 返回 true 且 y.equals(z) 返回 true 时，x.equals(z) 也应当返回true</li>
<li>一致性。对任意非 null 的 x 和 y，只要 equals 比较操作的对象没有变化，则多次调用 equals 时会返回同样的 true，或同样的 false</li>
<li>非空性。对于任意非 null 的引用 x, x.equals(null) 必须返回false<br>不要忽视其中的任一规定！在程序中，没有哪个类是孤立的。一个对象会被频繁地传给另一个对象，而许多类的正常运行（比如集合类）都依赖于正确的 equals 规定。接下来让我们逐条审视每条规定。<h3 id="1-自反性"><a href="#1-自反性" class="headerlink" title="1. 自反性"></a>1. 自反性</h3>自反性要求一个对象等于它自身。很难想象自反性会被违背。若违背了它，则当你能把它添加到一个集合里，却不能取出，而集合的<code>contains</code>方法会告诉你它不存在。<h3 id="2-对称性"><a href="#2-对称性" class="headerlink" title="2. 对称性"></a>2. 对称性</h3>对于任意两个对象，询问它们是否与对方相等，应当得到相同的答案。这条规则很容易在无意间被违反。设想你实现了一个不区别大小写的字符类：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CaseInsentiveString</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String s;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CaseInsentiveString</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.s = s;<br>    &#125;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(o <span class="hljs-keyword">instanceof</span> CaseInsentiveString)<span class="hljs-keyword">return</span> s.equalsIgnoreCase(((CaseInsentiveString) o).s);<br>        <span class="hljs-keyword">if</span>(o <span class="hljs-keyword">instanceof</span> String)<span class="hljs-keyword">return</span> s.equalsIgnoreCase((String) o); <span class="hljs-comment">//One-way interoperability!!</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>想法是很好的：不仅能和相同的类进行比较，也能和<code>String</code>类相互比较。不过问题在于，不符合对称性原则。设想一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">CaseInsentiveString cis = <span class="hljs-keyword">new</span> CaseInsentiveString(<span class="hljs-string">&quot;Polish&quot;</span>);<br>String s = <span class="hljs-string">&quot;Polish&quot;</span><br>cis.equals(s); <span class="hljs-comment">//return true</span><br>s.equals(cis); <span class="hljs-comment">//return false</span><br></code></pre></td></tr></table></figure>
<p>很显然，对于任意的 <code>String s</code>, <code>s.equals(cis)</code>都必然返回false。如果将它们放在一个集合里，比如<code>list</code>中，试图查询<code>list.contains(s)</code>都会得到不可预期的结果。也就是说，行为是不确定的（取决于JVM的实现）。<br>简单的修正方法是去掉试图和<code>String</code>比较的操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span>(o <span class="hljs-keyword">instanceof</span> CaseInsentiveString &amp;&amp; s.equalsIgnoreCase(((CaseInsentiveString) o).s);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-传递性"><a href="#3-传递性" class="headerlink" title="3. 传递性"></a>3. 传递性</h3><p>传递性要求：如果 a 等于 b，而 b 又等于 c，则 a 也要等于 b。这条规则也很容易在无意识间违反，特别是在实现<strong>添加了新的值的子类</strong>实现中。<br>设想你实现了一个类，它以坐标描述一个点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> y;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Point</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.x = x;<br>        <span class="hljs-keyword">this</span>.y = y;<br>    &#125;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> Point)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        Point p = (Point) o;<br>        <span class="hljs-keyword">return</span> p.x == x &amp;&amp; p.y == y;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>现在你想要扩展一下这个类，为它添加颜色信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColorPoint</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Point</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Color color;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ColorPoint</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, Color color)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(x, y);<br>        <span class="hljs-keyword">this</span>.color = color;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>现在想一想它的<code>equals</code>方法要怎么实现。如果不覆盖<code>equals</code>方法的话，那和其他<code>ColorPoint</code>比较时就完全不会考虑颜色信息。这显然不是我们想要的。那我们就仅当比较对象是一个<code>ColorPoint</code>时才进行比较：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span>(o instance of ColorPoint)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.equals(o) &amp;&amp; ((ColorPoint)o).color==color;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然而这个方法违背了对称性。当和具有坐标相同的<code>Point</code> <code>o</code>进行比较时，<code>o.equals(color_o)</code>返回 true，但<code>color_o.equals(o)</code>会返回 false。<br>如果我们编写一个<code>equals</code>方法，仅当对象是一个<code>ColorPoint</code>才考虑颜色信息，否则就当作<code>Point</code>比较，是不是就行了呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span>(!(o instance of Point))<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>  <span class="hljs-keyword">if</span>(!(o instance of ColorPoint))<span class="hljs-keyword">return</span> o.equals(<span class="hljs-keyword">this</span>);<br>  <span class="hljs-keyword">if</span>(o instance of ColorPoint)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.equals(o) &amp;&amp; ((ColorPoint)o).color==color;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>的确满足了对称性。但是产生了新的问题，首先这违背了传递性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ColorPoint p1 = <span class="hljs-keyword">new</span> ColorPoint(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,Color.RED);<br>Point p2 = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>ColorPoint p3 = <span class="hljs-keyword">new</span> ColorPoint(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,Color.BLUE);<br>p1.equals(p2); <span class="hljs-comment">//return true</span><br>p2.equals(p3); <span class="hljs-comment">//return true</span><br>p1.equals(p3); <span class="hljs-comment">//return false</span><br></code></pre></td></tr></table></figure>
<p>此时 p1 和 p2 相等，p2 和 p3 相等，但是 p1 和 p3 却不相等。而且，更严重的是，如果<code>Point</code>有多个子类，而且它们都采用这种方法实现<code>equals</code>方法，那么当彼此比较时会导致<strong>无限递归</strong>并爆栈。<br>那么应当如何解决呢？事实上，这无法解决。在面向对象语言中，你无法在扩展可实例化的类的同时，既增加新的值字段，又不违反 equals 约定。<br>你可以这样解决：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    ColorPoint p = (ColorPoint) o;<br>    <span class="hljs-keyword">return</span> p.colo=color &amp;&amp; <span class="hljs-keyword">super</span>.equals(o);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这可以解决问题。但是不像<code>instance of</code>会将子类和父类视为同一个类，<code>getClass()</code>方法要求类严格相同。很多时候，这种实现根本不能接受：<code>Point</code>的子类居然不是<code>Point</code>了！设想你想要检查某个点是否在单位圆中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Set&lt;Point&gt; unitCircle = Set.of(<br>        <span class="hljs-keyword">new</span> Point(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>),<span class="hljs-keyword">new</span> Point(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<br>        <span class="hljs-keyword">new</span> Point(-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>),<span class="hljs-keyword">new</span> Point(<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>)<br>);<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onUnitCircle</span><span class="hljs-params">(Point p)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> unitCircle.contains(p);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后你想好记录创建了多少个实例，于是扩展了<code>Point</code>类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountedPoint</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Point</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> AtomicInteger counter = <span class="hljs-keyword">new</span> AtomicInteger();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CountedPoint</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(x, y);<br>        counter.incrementAndGet();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numberCreated</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> counter.get();&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>若你将<code>CountedPoint</code>的实例传给<code>onUnitCircle</code>，无论<code>CountedPoint</code>的值是多少，都只会返回 false，因为<code>Point</code>的<code>equals</code>方法是基于<code>getClass</code>方法的。</p>
<blockquote>
<p>里氏替换原则：派生类（子类）对象可以在程序中代替其基类（超类）对象。  </p>
</blockquote>
<p>很明显，这种实现要牺牲面向对象的抽象所带来的好处。但是如果使用基于<code>instance of</code>的设计，就没有这种问题。<br>虽说鱼和熊掌不可兼得，不过折衷之道还是有的。此处可以遵从<strong>多用组合，少用继承</strong>的准则，让<code>Color</code>类成为<code>ColorPoint</code>类的一个组件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColorPoint</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Color color;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Point point;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ColorPoint</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, Color color)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.point = <span class="hljs-keyword">new</span> Point(x,y);<br>        <span class="hljs-keyword">this</span>.color = Objects./requireNonNull/(color);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Point <span class="hljs-title">asPoint</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> point;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!(o <span class="hljs-keyword">instanceof</span> ColorPoint))<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        ColorPoint cp = (ColorPoint) o;<br>        <span class="hljs-keyword">return</span> cp.point.equals(point) &amp;&amp; cp.color.equals(color);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>Java 类库中也存在一些违反了对称性的类，比如<code>Timestamp</code>类和<code>Date</code>类。如果你把它们放在一个集合里，就会引发不正确的行为。<code>Timestamp</code>类的注释中要求了程序员不要混用它们。<br>不过，对抽象类的子类增加值字段并不会违反对称性，因为父类是抽象类。只要确定定不会产生父类的实例，前述导致错误的情况就不会发生。</p>
<h3 id="4-一致性"><a href="#4-一致性" class="headerlink" title="4. 一致性"></a>4. 一致性</h3><p>一致性是指，除非被修改过，否则两个对象的<code>equals</code>方法返回的结果应当始终相同，不管被调用几次。不违反一致性的前提是不要让<code>equals</code>方法依赖于<strong>不稳定的资源</strong>。举个反面例子，<code>java.net.URL</code>的<code>equals</code>方法在实现上是判断URL中主机的IP地址是否相等。但是主机名转为IP地址需要访问网络，而且确实是可能会变的，这也在实践中引发了许多问题。要避免这种情况！<code>equals</code>方法应该只对内存中的对象执行确定性的计算。</p>
<h3 id="5-非空性"><a href="#5-非空性" class="headerlink" title="5. 非空性"></a>5. 非空性</h3><p>如果采用规范的编码，非空性是不必判断的。有的程序员喜欢在<code>equals</code>方法前加上一个显式的判空：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (o==<span class="hljs-keyword">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br></code></pre></td></tr></table></figure>
<p>但这其实是不必要的。因为你肯定要转换<code>Object</code>的类型为当前对象的类型，而在转换之前你一定会做一次类型检查：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(!(o instance of MyType))retrun <span class="hljs-keyword">false</span>;<br></code></pre></td></tr></table></figure>
<p>按 Java 规范，对于任意为 null 的对象，执行<code>instance of</code>检查一定会返回false。因此，显式的判空是不必要的。</p>
<h3 id="实现高质量-equals-方法的诀窍"><a href="#实现高质量-equals-方法的诀窍" class="headerlink" title="实现高质量 equals 方法的诀窍"></a>实现高质量 equals 方法的诀窍</h3><p><code>equals</code>方法的实现可以按以下流程：</p>
<ol>
<li>在<code>equals</code>方法的开始使用<code>==</code>运算符检查参数是否为对象自身的引用。这是一种小小的性能优化，不过很多时候很值。</li>
<li>使用<code>instance of</code>运算符检查参数的类型（以及是否为空）。至于正确的类型是类还是接口，取决你自己的实现。</li>
<li>转换参数为正确的类型。</li>
<li>检查参数对象中的每个<strong>关键</strong>字段是否与当前对象中对应的字段匹配。整型基本类型可以使用<code>==</code>运算符；浮点类型可以使用<code>Double.compare(double,double)</code>方法；数组可以使用<code>Arrays.equals</code>方法；对象引用可以递归调用其自身的<code>equals</code>方法，或者（如果可能为空的话）就使用<code>Object.equals</code>方法。<br>某些字段的比较操作可能开销较大，可以考虑把该字段存为<strong>正则形式</strong>。什么意思呢？比如说你想要记录单词的所有异位词，就可以把这个单词按字符排序。又比如之前所提到的<code>CaseInsensitiveString</code>类，每次都执行<code>equalsIgnoreCase</code>方法是代价非常高昂的，这时不妨这样存放：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String s;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CaseInsensitiveString</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-comment">//for real code probably use locale version</span><br>    <span class="hljs-keyword">this</span>.s = s.toLowerCase();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对于不可变类，这样的设计非常合适。<br>此外，为了提高性能，在比较时可以先比较<strong>最可能不一致</strong>的字段，或者比较<strong>开销最小</strong>的字段。对于不属于对象逻辑状态的字段，不必进行比较。某些衍生字段可能描述了对象的综合性特征。对于<code>Polygon</code>类，你就能可以先比较其面积，因为比较面积的代价远小于比较所有的顶点和边，而如果面积都不相同，也就不用继续比较了。<br>在编写完<code>equals</code>方法后，问一下自己：它是否满足对称性、传递性和一致性？然后编写一些单元测试来检验一下。你也可以用<code>autoValue</code>之类的框架来自动生成<code>equals</code>方法。<br>最后是一些要注意的细节：</p>
<ul>
<li>一定要同时覆盖<code>equals</code>方法和<code>hashCode</code>方法</li>
<li>不要企图让<code>equals</code>方法过于智能：不要过度寻找等价形式</li>
<li>不要替换<code>equals</code>签名中的<code>Object</code>对象。如果你这样做了，那么你没有覆盖(Override)这个方法，而是重载(Overload)这个方法。请善用<code>@Override</code>注解，它可以有效防止这种错误。<br>总结：不要轻易覆盖<code>equals</code>方法。如果你不得不覆盖，考虑用框架生成(比如<code>autoValue</code>)或者让IDE生成并进行细致的测试。别太相信自己手工编写的，而且一定要确保满足所有的准则：自反性、对称性、传递性、一致性和非空性。</li>
</ul>
<h2 id="11-同时覆盖-hashCode-方法"><a href="#11-同时覆盖-hashCode-方法" class="headerlink" title="11. 同时覆盖 hashCode 方法"></a>11. 同时覆盖 hashCode 方法</h2><h3 id="散列码的约定"><a href="#散列码的约定" class="headerlink" title="散列码的约定"></a>散列码的约定</h3><p>在每个覆盖了<code>equals</code>方法的类中，都要同时覆盖<code>hashCode</code>方法，否则会在所有基于散列的集合中导致错误的行为。约定如下：</p>
<ol>
<li>在程序运行期间，只要<code>equals</code>方法所涉及的信息不变，则<code>hashCode</code>所返回的值也应该不变。</li>
<li>若两对象根据<code>equals</code>方法比较是相等的，则调用<code>hashCode</code>也必须返回相等的整数值。</li>
<li>但两对象即使根据<code>equals</code>方法比较是不等的，但调用<code>hashCode</code>也可以返回相等的结果。但尽量给不等的对象返回不相等的<code>hashCode</code>会提高散列表的性能。<br>如果只覆盖了<code>equals</code>方法的，却没有覆盖<code>hashCode</code>方法，则会导致违反约定2, 这使得你在散列表内查找不到逻辑相等（但实例不同）的对象。设想你实现了一个电话号码类：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhoneNumber</span></span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> areaCode, prefix, lineNum;<br>  <span class="hljs-comment">//...省略构造函数</span><br>  <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!(o instance of PhoneNumber))<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    PhoneNumber p = (PhoneNumber)o;<br>    <span class="hljs-keyword">return</span> p.areaCode = areaCode &amp;&amp; p.prefix = prefix &amp;&amp; p. lineNum == lineNum;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后你把它插入到一个<code>HashMap</code>中并试图查找：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Map&lt;PhoneNumber,String&gt; addressBook = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>addreddBook.put(<span class="hljs-keyword">new</span> PhoneNumber(<span class="hljs-number">707</span>,<span class="hljs-number">865</span>,<span class="hljs-number">5309</span>),<span class="hljs-string">&quot;Jenny&quot;</span>);<br>PhoneNumber JennyNumber = addressBook.get(<span class="hljs-keyword">new</span> PhoneNumber(<span class="hljs-number">707</span>,<span class="hljs-number">865</span>,<span class="hljs-number">5309</span>));<span class="hljs-comment">//null!</span><br></code></pre></td></tr></table></figure>
<p>你的查找只会为空。因为按<code>Object</code>提供的<code>HashCode</code>它们并不相同。修正的方法非常简单：提供一个<code>HashCode</code>即可。那么如下编写如何？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;&#125;<br></code></pre></td></tr></table></figure>
<p>这个<code>HashCode</code>方法是合法的：但是非常恶劣。它会导致所有的对象都被映射到同一个散列桶里，导致散列表退化为链表，致使许多算法时间复杂度大幅提高。一个好的散列函数应该尽可能保证<strong>为不相等的对象产生不相等的散列码</strong>。理想情况下，散列函数应该尽可能地把所有的实例均匀分布到所有可能int值上。</p>
<h3 id="一个参考实现"><a href="#一个参考实现" class="headerlink" title="一个参考实现"></a>一个参考实现</h3><p>如果你不知道怎么做，以下是一个简单的参考：</p>
<ol>
<li>计算对象中的每个关键字段的散列码<code>int c</code>：<ol>
<li>如果是基本类型，则使用<code>Type.hashCode(f)</code>方法。其中<code>Type</code>是基本类型的装箱类。</li>
<li>如果是对象，则参照它的<code>equals</code>方法，递归地调用其<code>hashCode</code>方法。对于非常复杂的对象，可以保存其<strong>正则形式</strong>。如果是null，通常可以简单地返回0.</li>
<li>如果是数组，则把每个元素当作一个单独的字段处理。</li>
</ol>
</li>
<li>对于所有的<code>c</code>，计算<code>result = 31*result + c</code></li>
<li>返回<code>result</code>，并编写单元测试检测是否有“相等的实例却有不等的散列值”的情况。</li>
</ol>
<p>对于以上简单的<code>hashCode</code>函数，有几点值得说明：</p>
<ul>
<li>连续乘法使得结果依赖于字段的顺序。对于含有多个相似字段的对象，这样能得到更好的散列码。你肯定不希望所有字母异位词字符串都有相同的散列码吧？</li>
<li>使用31作为系数。通常不会用偶数，因为采用偶数，如果乘法溢出的话就会丢失部分信息：与2相乘和移位是一样的。</li>
<li>用字面量常数使得编译器可以优化：<code>31*i==(i&lt;&lt;5)-i</code></li>
</ul>
<p>本条目中给出的散列函数只是一个参考。如果你需要更低的碰撞概率，请参考 Guava’s com.google.common.hash.Hashing[Guava]。</p>
<p>对于不可变且计算散列函数开销较大的类，可以考虑把散列码缓存在对象内部。如果你觉得它可能不会用到<code>hashCode</code>，可以采用<strong>延迟初始化</strong>，即在首次调用时才初始化。下面是对<code>PhoneNumber</code>类的一个实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> hashCode; <span class="hljs-comment">//初始值默认是0</span><br><span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">int</span> result = hashCode;<br>  <span class="hljs-keyword">if</span>(result==<span class="hljs-number">0</span>)&#123;<br>    result = Short.hashCode(areaCode);<br>    result = <span class="hljs-number">31</span>*result + Short.hashCode(prefix);<br>    result = <span class="hljs-number">31</span>*result + Short.hashCode(lineNum);<br>    hashCode = result;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="警惕小“聪明”"><a href="#警惕小“聪明”" class="headerlink" title="警惕小“聪明”"></a>警惕小“聪明”</h3><blockquote>
<p>注意：不要试图从散列码中排除某些关键字段来“提高”性能。</p>
</blockquote>
<p>通常你这样的做法都是适得其反。可能你的散列函数会运行得稍微快点，但会大幅降低散列表的性能。在很多情况下，对象的实例非常之多，以至于有大量其他字段相同，但在你忽略的字段上区别很大的实例。散列函数会把它们映射到同一个桶内，导致运行时间从常数提高到线性。事实上，Java 2版本前的<code>String.hashCode()</code>就只至多均匀采样16个字符，导致在URL这类层次结构的大型字符串上运行速度缓慢。</p>
<p>此外，不要对<code>hashCode</code>的返回值作出任何明确的约定。这给了你日后改进散列函数的灵活性。如果不想费力自己实现，可以使用<code>autoValue</code>框架，或者让IDE帮你干活——和<code>equals</code>方法是一样的。</p>
<h2 id="12-最好覆盖-toString"><a href="#12-最好覆盖-toString" class="headerlink" title="12. 最好覆盖 toString"></a>12. 最好覆盖 toString</h2><p>虽然<code>Object</code>提供了<code>toString</code>的一个实现，不过它返回的结果可读性实在很差。<code>toString</code>的通用约定要求，返回值应当<strong>“简洁但信息丰富，且易于阅读”</strong>。而且它还指出，<strong>“建议所有子类都覆盖此方法”</strong>。</p>
<p>当然，遵守<code>toString</code>约定并不那么重要，但它可以让类使用起来更加舒适，也更利于调试。在日志的错误提示中，经常会有某对象的<code>toString</code>表示，如果你没有覆盖<code>toString</code>，那这条信息可能就毫无用处。还记得上文所述的<code>PhoneNumber</code>类吗？你可能会这样调试它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;Faild to connect&quot;</span>+phoneNumber);<br></code></pre></td></tr></table></figure>
<p>不管有没有覆盖<code>toString</code>方法，你都可能都会以这样的方式来产生诊断消息。但如果没有覆盖<code>toString</code>方法，那输出的消息都难以理解。提供好的<code>toString</code>方法，有时不仅是为了这个类的实例，更是为了可能会持有这些类的对象（比如集合）。想想如果打印Map时输出的消息是<code>&#123;Jenny = PhoneNumber@163b91&#125;</code>，你会是什么心情？</p>
<p>实际应用中需要注意，<code>toString</code>方法应当返回对象中包含的<strong>所有</strong>值得关注的消息。如果对象太大，或者难以以字符串形式表述，可以返回一个摘要信息。理想情况下，你输出的内容应该是<strong>自描述</strong>的。</p>
<p>如果没有包含所有必要的信息？看看这个错误报告吧：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Assertion</span> failure: expect &#123;abc, <span class="hljs-number">123</span>&#125;, but was &#123;abc, <span class="hljs-number">123</span>&#125;.<br></code></pre></td></tr></table></figure>
<h3 id="要不要确定格式？"><a href="#要不要确定格式？" class="headerlink" title="要不要确定格式？"></a>要不要确定格式？</h3><p>如果是值类，比如说电话号码、矩阵、区号之类的，可以这么做。确定一种标准的、明确的、适合阅读的表示法，有利于标准化的输入和输出，还能用在具有强可读性的文件中，比如csv格式。如果你确定了格式，建议再添加一个相匹配的静态工厂或构造器用于字符串和对象间的转换。事实上，Java类库中就有不少类这么做了，比如<code>BigInteger</code>类和大部分基本类型的装箱类。</p>
<p>但是如果你指定了格式，而且你的类已经被广泛使用了，那么为了兼容性考虑，往往就要一直使用这种格式，不能随意修改。所以，不指定明确的格式，可以为未来的改进保留灵活性。</p>
<p>无论如何，你都应该<strong>在注释中明确地说明你的意图</strong>，并严格执行。比如，你要是不打算确定格式，最好这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Returns a brief description of this potion. The exact details</span><br><span class="hljs-comment">* of the representation are unspecified and subject to change,</span><br><span class="hljs-comment">* but the following may be</span><br><span class="hljs-comment">* regarded as typical: </span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* &quot;[Potion #9: type=love, smel1=turpentine, 1ook=india ink]”</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">/*do toString()...*/</span>&#125;<br></code></pre></td></tr></table></figure>
<p>对于那些读到注释却还是打算依赖于格式编程或产生持久性数据的程序员，他们就得为自己的行为负责了。</p>
<h3 id="不要迫使他人解析字符串"><a href="#不要迫使他人解析字符串" class="headerlink" title="不要迫使他人解析字符串"></a>不要迫使他人解析字符串</h3><p>对于任何你会在<code>toString</code>方法中提供的信息，你都应该在类中（或别的编程手段）提供便捷的访问方法，否则其他需要这些信息的人就可能会去解析<code>toString</code>方法产生的字符串。这不仅不必要，还会导致系统不稳定。一旦字符串表示法发生变化，系统就可能崩溃。如果你不提供这类便捷方法，即使你在注释中声明字符串是可变的，也会导致其成为事实上的API。</p>
<h3 id="有时不必覆盖-toString-方法"><a href="#有时不必覆盖-toString-方法" class="headerlink" title="有时不必覆盖 toString 方法"></a>有时不必覆盖 toString 方法</h3><ul>
<li>在静态工具类中不必覆盖<code>toString</code>方法，因为它不会被实例化。</li>
<li>在枚举类型中也不必覆盖<code>toString</code>方法，因为Java已经提供了。</li>
<li>对于那些子类会共享<code>toString</code>方法的类，比如大多数集合类，一定要覆盖<code>toString</code>方法。</li>
</ul>
<h2 id="13-谨慎覆盖-Clone-方法"><a href="#13-谨慎覆盖-Clone-方法" class="headerlink" title="13. 谨慎覆盖 Clone 方法"></a>13. 谨慎覆盖 Clone 方法</h2><p><code>Cloneable</code>接口设计出来是想要成为一个混合类型接口，用于描述这样的对象可以克隆。然而它是有缺陷的，由于<code>Object</code>类提供的<code>clone</code>方法是<code>protected</code>的，因此你不能因为类实现了<code>Cloneable</code>接口，就确保它的<code>clone</code>方法一定可以调用。甚至通过反射调用也不一定可行，因为类的<code>clone</code>方法可能是不可访问的。</p>
<p><code>Cloneable</code>接口不包含任何方法。不过，如果类实现了<code>Cloneable</code>接口，那么<code>Object</code>的<code>clone</code>在调用时就会返回该类的一个拷贝，否则抛出<code>CloneNotSupportedException</code>异常。</p>
<blockquote>
<p>这是接口的极端非典型用法，不值得效仿。实现接口原本是为了说明类的行为，但<code>Cloneable</code>接口改变了类的行为。</p>
</blockquote>
<p>尽管规范中没有明确指出，但实现<code>Cloneable</code>的类是为了提供一个公有且功能适当的<code>clone</code>方法。为此，该类及其所有父类都必须去调用一个相当复杂且几乎没有文档说明的、独立于语言之外的特殊机制：<code>Cloneable</code>机制。这个机制允许不调用构造器就创建对象。</p>
<p><code>clone</code>方法的通用约定如下：</p>
<ul>
<li><p>一般地，对于任意对象<code>x</code>，表达式<code>x.clone()!=x</code>结果为<code>true</code>, 且表达式<code>x.clone().getClass()==x.getClass()</code>结果为<code>true</code>, 而且通常情况下，<code>x.clone().equals(x)</code>也应该为<code>true</code>。但这并不是绝对的要求。</p>
</li>
<li><p>同时，返回的对象不应该依赖于原有的对象。</p>
</li>
<li>最后，此方法返回的对象应该通过<code>super.clone</code>获得。</li>
</ul>
<p>最后这种机制大体上相当于自动的构造器调用链，但它并不是强制要求的，即使你直接通过构造器获取，编译器也不会报错。但如果你这样实现了一个类，但又在它的子类里调用<code>super.clone</code>方法，这个类大概率是不会正常运行的。当然，如果是 final 类，那可以随意，甚至不必去实现<code>Cloneable</code>接口。</p>
<h3 id="简单实现-clone-方法"><a href="#简单实现-clone-方法" class="headerlink" title="简单实现 clone 方法"></a>简单实现 clone 方法</h3><p>下面谈一谈实现<code>clone</code>方法的技巧。假定你需要为一个类实现<code>Cloneable</code>接口，而且它的父类都提供了良好的<code>clone</code>方法实现。首先，你需要调用<code>super.clone</code>方法，它会完整地复制当前类的所有字段。如果当前类的每个字段都是基本类型或不可变类型，那就可以不必进行下一步工作了，直接返回就好。拿之前的<code>PhoneNumber</code>举例好了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> PhoneNumber <span class="hljs-title">clone</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-keyword">return</span> (PhoneNumber)<span class="hljs-keyword">super</span>.clone();<br>  &#125;<span class="hljs-keyword">catch</span>(CloneNotSupportedException e)&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上述方法调用了<code>Object.clone</code>方法，它返回的是一个<code>Object</code>，所以需要进行一次强转。当然，实际上返回的是一个<code>PhoneNumber</code>类，所以转换是一定会成功的。</p>
<p>记得不可变类就不要提供<code>clone</code>方法了，这种类的克隆只是浪费资源。</p>
<h3 id="深拷贝实现-clone-方法"><a href="#深拷贝实现-clone-方法" class="headerlink" title="深拷贝实现 clone 方法"></a>深拷贝实现 clone 方法</h3><p>如果类包含可变对象作为字段，那么用上述方法实现会产生灾难性的后果。比如说你实现的是一个栈，而它的<code>clone</code>方法只返回<code>super.clone</code>方法，这样克隆出来的对象内部的数组引用将会与原对象相同，一旦原对象被修改，当前对象也会被破坏，反之亦然。这可不是什么好事。</p>
<p>你必须确保克隆出来的对象是一个独立的新对象，虽然它持有相同的信息。像<code>Stack</code>类，它必须拷贝栈的内部信息。常规的做法是递归地调用<code>clone</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Stack <span class="hljs-title">clone</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">try</span>&#123;<br>    Stack result = (Stack)<span class="hljs-keyword">super</span>.clone();<br>    result.elements = <span class="hljs-keyword">this</span>.elements.clone();<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<span class="hljs-keyword">catch</span>(CloneNotSupportedException e)&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意，数组不用强转。这还是挺好的。不过如果数组是 final 的，那么上述方案就不行，而且也没有方案能行。根本问题在于：<code>Cloneable</code>机制与引用可变对象的 final 字段是不相兼容的。如果你的类必须是<code>Cloneable</code>的，那么就可能必须得去掉一些字段的 final 修饰符。</p>
<p>有时候递归地调用<code>clone</code>还不够。你的类可能是数组套链表，像散列表，甚至更加复杂。你需要巧妙地逐层调用<code>super.clone</code>方法。不过你也可以选择先调用<code>super.clone</code>方法，再调用别的方法再重建对象的状态。还是拿散列表为例吧，你可以先<code>super.clone</code>出一个散列表对象，然后清空里面的内容，再对原散列表的内容逐个调用<code>put(key, value)</code>方法填进去。这种方法更加合理，不过效率不如<code>Cloneable</code>机制。</p>
<h3 id="super-clone-的其他注意事项"><a href="#super-clone-的其他注意事项" class="headerlink" title="super.clone 的其他注意事项"></a>super.clone 的其他注意事项</h3><ul>
<li><p><code>clone</code>不应该调用在子类中会被覆盖的方法。因为可能会在对象的状态被克隆前就调用此方法。<code>clone</code>方法调用的方法要么是私有的，要么就是 final 的。</p>
</li>
<li><p><code>Object.clone</code>方法会抛出<code>CloneNotSupportedException</code>异常，但覆盖的版本最好省略掉这个异常——当然是因为不抛出异常的方法用起来更加轻松啦。</p>
</li>
<li><p>在设计父类时，你可以考虑像<code>Object</code>一样实现一个<code>protected T clone() throws CloneNotSupportedException</code>方法，让子类去选择要不要实现<code>Cloneable</code>接口。或者不实现一个有效的<code>clone</code>方法，并防止子类实现<code>clone</code>：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException</span>&#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span>  CloneNotSupportedException();<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>最后一点，如果你要为线程安全的类实现<code>Cloneable</code>接口，记得要严格同步它的<code>clone</code>方法。</li>
</ul>
<h3 id="替代解决方案"><a href="#替代解决方案" class="headerlink" title="替代解决方案"></a>替代解决方案</h3><p>如果你觉得上述的<code>Cloneable</code>实现过于复杂……你是对的。其实大部分时候不需要这么复杂（除非你继承了一个实现了<code>Cloneable</code>接口的类）。更好的做法其实是提供一个拷贝构造器，或者拷贝工厂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Copy constructor</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Foo</span><span class="hljs-params">(Foo foo)</span></span>&#123; ... &#125;;<br><span class="hljs-comment">//Copy Factory</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Foo new <span class="hljs-title">Instance</span><span class="hljs-params">(Foo foo)</span></span>&#123; ... &#125;;<br></code></pre></td></tr></table></figure>
<p>相比于什么<code>Cloneable</code>接口，以上方案具有明显的好处：</p>
<ul>
<li>不依赖于某一独立于语言的特殊机制</li>
<li>不要求遵守某一没有文档的规范</li>
<li>不会和 final 字段的正常使用冲突</li>
<li>不会抛出没必要的奇妙异常</li>
<li>不需要类型转换</li>
</ul>
<p>甚至你可以实现一个带参数的拷贝构造器/工厂（接口里通常都提供了一个拷贝构造器）以允许用户选择自己拷贝的实现类型，而不是原始的实现类型。比如，你提供了一个<code>HashSet s</code>，想要把它拷贝成<code>TreeSet</code>。<code>clone</code>方法是不可能实现的；但用转换构造器就很容易了：<code>new TreeSet&lt;&gt;(s)</code>。</p>
<p>总之，大部分情况下不要去扩展<code>Cloneable</code>接口也别去实现<code>clone</code>方法。把它当作一种少数极端情况下的性能优化手段更好。唯一的例外情况是数组：数组用<code>clone</code>方法拷贝最佳。</p>
<h2 id="14-考虑实现-Comparable-接口"><a href="#14-考虑实现-Comparable-接口" class="headerlink" title="14. 考虑实现 Comparable 接口"></a>14. 考虑实现 Comparable 接口</h2><p><code>compareTo</code>方法其实没有在<code>Object</code>类中声明，它是<code>Comparable</code>接口里面唯一的方法。不过它和<code>equals</code>方法有诸多相似之处。它实现了类的顺序比较，而且是个泛型方法。实现了<code>Comparable</code>方法暗示类具有内在的顺序关系。如果违反<code>Comparable</code>约定，就会影响所有的基于比较关系的集合类和方法，包括<code>TreeSet</code>, <code>TreeMap</code>, <code>Collections</code>和<code>Arrays</code>中的搜索和排序算法。如果实现了<code>Comparable</code>接口，一切都那么简单：</p>
<p>以下是一个命令行软件的参数解析类，作用是去除所有重复的参数并按字母顺序重排：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WordList</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;String&gt; <span class="hljs-title">getArgs</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Set&lt;String&gt; s = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;();<br>    Collections.addAll(s,args);<br>    <span class="hljs-keyword">return</span> s;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>想想看，你的类只要实现了<code>Comparable</code>接口，就能享受到许多的泛型算法带来的好处。事实上，Java类库中几乎所有的值类都实现了<code>Comparable</code>接口。如果你要写一个具有内在顺序关系的类，比如字母顺序、时间顺序、数值顺序等等，你都应该主动实现<code>Comparable</code>接口。</p>
<h3 id="通用约定"><a href="#通用约定" class="headerlink" title="通用约定"></a>通用约定</h3><p><code>compareTo</code>方法的通用约定类似于<code>equals</code>方法的约定：</p>
<ul>
<li><p>将当前对象与指定的对象进行比较，当当前对象小于、等于或等于当前对象时，方法依次返回一个负整数、零或正整数。若指定对象无法与当前对象进行比较，则抛出一个<code>ClassCastException</code>异常（下文中的符号<code>sgn(expression)</code>代表数学中的 $signum$ 函数）。</p>
</li>
<li><p>对于所有的<code>x</code>和<code>y</code>，应当满足:</p>
<ul>
<li><p><code>sgn(x.compareTo(y))==-sgn(y.compareTo(x))</code>;</p>
</li>
<li><p>若<code>x.compareTo(y)&gt;0 &amp;&amp; y.compareTo(z)&gt;0</code>，有<code>x.compareTo(z)&gt;0</code>。其他情况亦然；</p>
</li>
<li><p>若<code>x.compareTo(y)==0</code>，则对任意<code>z</code>满足<code>sgn(x.compareTo(z))==sgn(y.compareTo(z))</code>成立；</p>
</li>
<li><p>虽不必要，但强烈建议<code>(x.compareTo(y)==0) == (x.equals(y))</code>。若不满足此条件，应明确在注释中给予说明，如：</p>
<p>“注意：该类具有内在的排序关系，但与 equals 不一致。“</p>
</li>
</ul>
</li>
</ul>
<p>上述条件虽然复杂，但其核心与<code>equals</code>方法是类似的。而且相比于<code>equals</code>的复杂性，<code>compareTo</code>要求不能跨对象比较，其实实现时更加简单。上述条件翻译一下就是：</p>
<ul>
<li>对称性：若 $a&gt;b$ 成立，则 $b&lt;a$ ;</li>
<li>传递性：若 $a&gt;b, b&gt;c$ 成立，则 $a&gt;c$</li>
<li>一致性：相等的两个对象，与其他对象的比较结果也相等</li>
</ul>
<p><code>compareTo</code>和<code>equals</code>方法的相似之处还在于，不可能以继承的形式为实现了<code>Comparable</code>接口的类增加值字段。你只能实现一个新类，包含原来的类，并把在必要时把原来的类实例作为新类的一个“视图”返回。</p>
<p>最后一条要求并非强制，但最好实施。如果违反了此规定，这个类依然可以顺利运行，不过包含此类的有序集合（比如说<code>Set</code>或<code>Map</code>）可能无法遵守相应集合接口的通用约定。如果你打算这么做，最好对这些集合类的通用约定有所了解：</p>
<blockquote>
<p>例如，在<code>HashSet</code>中添加<code>new BigDecimal(&quot;1.0&quot;)</code>和<code>new BigDecimal(&quot;1.00&quot;)</code>，集合中将包含两个实例。</p>
<p>但是在<code>TreeSet</code>中添加这两个实例的话，集合中只包含一个实例。</p>
</blockquote>
<h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>总体的实现方法还是和<code>equals</code>一样，对关键字段按重要性逐个调用<code>compareTo</code>方法，或装箱类的<code>Type.compare</code>方法。建议不要在<code>compareTo</code>中使用<code>&lt;</code>和<code>&gt;</code>号，非常烦琐，而且也容易出错。</p>
<p>由于在<code>compareTo</code>方法中经常要按一定顺序比较字段，因此<code>Comparator</code>接口配置了一组比较器构造方法，使用它能写出非常流畅的代码。以下是对之前的<code>PhoneNumber</code>类使用比较器构造方法编写的<code>compareTo</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Comparator&lt;PhoneNumber&gt; COMPARATOR = <br>    comparingInt((PhoneNumber p) -&gt; p.areaCode)<br>    .thenComparingInt(p --&gt; p.prefix)<br>    .thenComparingInt(p --&gt; p.lineNum);<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(PhoneNumber p)</span></span>&#123;<br>  <span class="hljs-keyword">return</span> COMPARATOR.compare(<span class="hljs-keyword">this</span>,p);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Comparator类包含全套构造方法，对于<code>long</code>, <code>int</code>和<code>double</code>都有支持。如果要比较<code>short</code>和<code>float</code>类型，使用<code>int</code>和<code>doublt</code>版本就行了。</p>
<p>少数情况下你可能只需要判断两个值是否不同：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//BROKEN difference-based comparator</span><br><span class="hljs-keyword">static</span> Comparator&lt;Object&gt; hashCodeOrder = <span class="hljs-keyword">new</span> Comparator&lt;&gt;()&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object o1,Object o2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> o1.hashCode()-o2.hashCode(); <span class="hljs-comment">//don&#x27;t do that!</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上述写法并不好，它很容易溢出，而且违反IEEE 754浮点运算规范。最好还是用静态<code>compare</code>方法或者比较器构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Comparator based on static compare method</span><br><span class="hljs-keyword">static</span> Comparator&lt;Objects hashCodeOrder = <span class="hljs-keyword">new</span> Comparator&lt;&gt;() &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span> <span class="hljs-params">(Object o1, Object o2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Integer.compare(o1.hashtode(), o2.hashCode())；<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// Comparator based on Comparator construction method</span><br><span class="hljs-keyword">static</span> Comparator&lt;Object&gt; hashCodeOrder = <br>Comparator.comparingInt(o -&gt; o.hashCode())；<br></code></pre></td></tr></table></figure>
<p>总之，尽量用Java类库提供的方法。</p>
</div></article><div class="post-view__sidebar"><div class="sidebar"><div class="tocbot"><h2>Toc</h2><div class="toc__content"></div></div><h2>Links</h2><div class="sidebar__link"><ul><li><a target="_blank" rel="noopener" href="https://github.com/gloryalex">Github</a></li><li><a href="mailto:gloryxie@icloud.com">Mail</a></li><li><a href="/atom.xml">Rss</a></li></ul></div><h2>Archives</h2><div class="sidebar__archives"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a></li></ul></div><h2>Categories</h2><div class="sidebar__categories"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></li></ul></div><h2>Tags</h2><div class="sidebar__tags"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Effective-Java/" rel="tag">Effective Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EffectiveJava/" rel="tag">EffectiveJava</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HeadFirstServlet/" rel="tag">HeadFirstServlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaWeb/" rel="tag">JavaWeb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RegExp/" rel="tag">RegExp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Servlet/" rel="tag">Servlet</a></li></ul></div></div></div></div><div class="horizontal-line" style="height: 1px"></div><div class="main__bottom"><div class="pre-next"><a class="pre-button" href="/2021/05/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/">三. 类和接口</a><a class="next-button" href="/2021/04/12/%E4%B8%BB%E6%B5%81%E8%AF%AD%E8%A8%80%E5%AF%B9%E6%AD%A3%E5%88%99%E7%9A%84%E6%94%AF%E6%8C%81/">主流语言对正则的支持</a></div></div></div></div><div class="footer"><span>©️2019-2021 Designed By&nbsp;<strong><a target="_blank" rel="noopener" href="https://github.com/random-yang">RandomYang</a></strong> Powered By&nbsp;</span><strong><a target="_blank" rel="noopener" href="https://hexo.io">hexo</a></strong></div><div class="darkmode-mask" id="darkmode-mask"></div><div class="sidebar__button"></div></body></html>