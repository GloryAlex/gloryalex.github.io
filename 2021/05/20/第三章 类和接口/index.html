<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=0"><meta name="description" content="三. 类和接口 [ A-Grain-Of-Sands ] "><meta name="theme-color" content="#ebc65a"><title>三. 类和接口 [ A-Grain-Of-Sands ] </title><style>@font-face {
  font-family: 'Abril Fatface';
  font-style: normal;
  font-weight: 400;
  src: local('Abril Fatface'), local('AbrilFatface-Regular'), url(data:font/woff2;base64,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) format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Abril Fatface';
  font-style: normal;
  font-weight: 400;
  src: local('Abril Fatface'), local('AbrilFatface-Regular'), url(data:font/woff2;base64,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BL3+M1K+NfPvjlJEHZTOrkYvtdprqx0Hka+W/IhsQoUJE0jsPVOhV2itgp3Wame8dsB73DeCOfp+FMSxp2At3aozP1zVQ/tmEpXdveum7kat3CaLXRcmTZHmOveMiqxSteCZOrGKmscOa9WycTUXtRFabrtts1Nb3e5qHtqWPMWtuEkMSdydcarhKoTcVXtBgujKwULbPFJvqywIzBjboUacECG6ajlIews5dBUMkJ/LYHa12gpRLEsBDAAA6raxOaTnbx4GG5J6hdn4twxT1DRvEQZvD6banOa3BbstVh48efHmw5cffwECBQkWIvK/LTbhIkSKEi1GrDjxEiRKkixFqjTpMmTKki1Hrjz5ChQqUqxEqTLlKlSqUq2e+hpoqJHGmmiqmeZhWGKoYfaZ7qXhxhtjnlWWxsBotw0xxWdfjDPDSEfc98l8q33z1XeLrXPKCeu10NJErZzR2kmnXXDWOee90sYVF12yQVsfTXLdVde088Y7o3TQXkedddLFQnb/qVGrq24cuuvhtZ5666WPfvraaZEB+htokLfe2+1GBDbalARuuueWzbbYboejttrmmBHW2O+AvUmRDMb6EEUsHHQoDskRjxRIiVRILev2qn1oaGpomZOB2z/jmn/eUk6tvaZda/5znbhPCguQ7wsEvd1strBI3OYR8ye01+ZO0jbH36oqKm37w90hl2v/wO5o3vIjtpoZx20H) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
</style><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><script src="https://cdn.bootcss.com/highlight.js/9.6.0/highlight.min.js" defer></script><script src="/js/paper.js" defer></script><script src="https://www.googletagmanager.com/gtag/js?id=xx-xxxxxxx-xx" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'xx-xxxxxxx-xx');</script><link rel="stylesheet" href="/css/tocbot.css"><script src="/js/tocbot.js" defer></script><script>window.addEventListener('DOMContentLoaded', () => {
  tocbot.init({
    // Where to render the table of contents.
    tocSelector: '.toc__content',
    // Where to grab the headings to build the table of contents.
    contentSelector: '.article__content',
    // Which headings to grab inside of the contentSelector element.
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    // For headings inside relative or absolute positioned containers within content.
    hasInnerContainers: true,
    orderedList: false,
    collapseDepth: 2,
  });
})</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
  }
});
MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
  }
});</script><link rel="preload" href="https://cdn.bootcss.com/highlight.js/9.6.0/styles/github.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.6.0/styles/github.min.css"><link rel="preload" href="https://fonts.googleapis.com/css?family=Abril+Fatface&amp;display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface&amp;display=swap"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="A-Grain-Of-Sands" type="application/atom+xml">
</head><body><div class="mask-border"></div><div class="head"><div class="head__inner"><h1><a href="/">A-Grain-Of-Sands</a></h1><p>a little site, a few techies</p></div></div><div class="paper-container"><div class="main"><div class="location-bar"><div class="line-1"><div class="horizontal-line" style="height: 3px"></div></div><div class="line-2"><div class="horizontal-line" style="height: 1px"></div></div><p class="text">三. 类和接口</p><div class="switch-button"><input class="container_toggle" type="checkbox" id="switch" name="mode"><label for="switch">Toggle</label></div><div class="line-3"><div class="horizontal-line" style="height: 1px"></div></div></div><div class="main__2-col"><article class="post-view__article"><div class="article__infomation"><div class="posts-item"><h2 class="posts-item__title"><a href="">三. 类和接口</a></h2><span class="post__date">2021-05-20</span><a href="/tags/Java/"><span class="post__tags">#Java</span></a><a href="/tags/EffectiveJava/"><span class="post__tags">#EffectiveJava</span></a></div></div><div class="article__content"><blockquote>
<p>本文是我的 <em>Effective Java 3rd Edition</em> 读书笔记。本书翻译较差，建议阅读英文版。</p>
</blockquote>
<p> 本章主要阐述了关于Java的基本抽象：类和接口相关的一些原则和实践指导。</p>
<span id="more"></span>
<h2 id="15-使类和成员的可访问性最小化"><a href="#15-使类和成员的可访问性最小化" class="headerlink" title="15. 使类和成员的可访问性最小化"></a>15. 使类和成员的可访问性最小化</h2><p>要评价一个模块的设计，最重要的评价因素就是它是否对外界地隐藏了内部数据和实现细节。设计良好的模块会隐藏所有不必要 的实现细节，把 API 和实现清晰地隔离开来。一个模块不需要知道其他模块内部是如何实现的——只要知道它<strong>可以做到什么</strong>就行了。这就是软件工程领域最重要的原则之一：<strong><ruby>信息隐藏<rt>information hiding</rt></ruby></strong>，或者说<strong><ruby>封装<rt>encapsulation</rt></ruby></strong>。</p>
<h3 id="为什么要封装"><a href="#为什么要封装" class="headerlink" title="为什么要封装"></a>为什么要封装</h3><p>封装可以有效地解除组成系统的各模块之间的耦合关系，使得这些模块可以独立地开发、测试、优化、使用和修改，使得模块们可以并行开发，同时也减轻了维护的负担——程序员们可以更快地理解各模块的作用，并在调试时不影响其他组件。虽然解耦看似不能提高性能，但它降低了性能调优的难度：通过整体剖析，可以发现具体是哪些模块影响了系统的性能，然后针对性地优化模块而不影响其他组件的正常运转。同时，封装也提高了软件的复用性，因为模块们彼此并不紧密相连，因此需要时可以轻易地在其他环境中复用。最后，封装还降低了构建大型软件系统的风险，这点不用详细解释吧。</p>
<h3 id="Java-中的访问控制"><a href="#Java-中的访问控制" class="headerlink" title="Java 中的访问控制"></a>Java 中的访问控制</h3><p>Java提供了许多机制来协助封装，访问控制机制是其中之一。访问控制决定了类、接口及成员的可访问性。实体的可访问性由实体所处的位置，以及其声明中的访问修饰符决定。如何正确使用它们？请牢记以下规则：</p>
<blockquote>
<p>尽可能使每个类和成员不被外界访问。</p>
</blockquote>
<p>对于顶层类和接口，其访问级别只能是公有或包访问级别。如果类或接口可以实现为包访问级别，那就最好把它实现为包访问级别。这样一来，它就是包的一部分，而不是API的一部分——只要你需要，你可以随时修改、替换或删除。但如果是公有的，你就必须一直兼容它。</p>
<p>如果某个包访问级别的类只会为其他的某一个特定的类所用到，那就应该把它声明为（唯一会使用它的）那个类的内部类。这样可以把它的访问性缩小到访问它的那个类。不过更重要的是尽可能减少不必要的公有类，因为公有类是包API的一部分。</p>
<p>类的成员有四种访问级别（从低到高）：</p>
<ul>
<li>私有：仅有该类的内部成员可以访问；</li>
<li>包访问：同一个包的任何类都可以访问。是类成员的默认访问级别；</li>
<li>受保护：仅有该类的内部成员及其子类可以访问；</li>
<li>公有：任何类都可以访问；</li>
</ul>
<h3 id="较低访问级别"><a href="#较低访问级别" class="headerlink" title="较低访问级别"></a>较低访问级别</h3><p>在仔细设计过类的公有API后，其他所有成员都可以设为私有的。只有你确实发现包内的另一个类需要访问这个成员时，才应该删除<code>private</code>修饰符（把它设为包访问级别）。不过，如果你总是在做这种操作，更应该做的事是重构，看看能否重新分解类以降低耦合性。虽说私有和包访问成员都是类实现的一部分，不会影响公有API，但是如果是可序列化的类，部分字段可能会被“泄露”到公有API中。</p>
<p>受保护级别是包的API的一部分，它和公有API一样也代表了类对于某个实现细节的公开承诺。应该少用受保护级别。由于里氏替换原则<sup><a href="#fn_1" id="reffn_1">1</a></sup>的存在，任何覆盖父类方法的子类成员的访问级别都不能低于原有访问级别。</p>
<p>有时候为了测试代码，你可以适当提高类或成员的访问级别，不过至多提高到包访问级别就够了——而且也没必要再提高了，测试类可以作为包的一部分来运行。</p>
<h3 id="较高访问级别"><a href="#较高访问级别" class="headerlink" title="较高访问级别"></a>较高访问级别</h3><p>公有类往往会有许多非静态成员。<strong>所有的非静态成员绝不能是公有的</strong>。如果这个成员是非 final 的，或是指向可变对象的 final 引用，那么当你把它设为公有访问级别时，就相当于放弃了对存储在这个成员中的值进行限制的能力；这也意味着你放弃了使这个字段不可变的能力；你也失去了对字段被修改时执行任何操作的能力。而且，包含公有可变成员的类通常不是线程安全的。即使是 final 不可变成员，你声明其为公有的，也失去了“切换到另一种新的内部表示法”的自由。</p>
<p>对于静态成员，其实大部分情况也相同。只有一种情况例外——就是常量构成了类抽象的一部分。这时候可以公开这些常量，按惯例，它们应该名称大写，单词间由下划线隔开，其类型必须是基本类型或指向不可变对象的引用。如果 final 成员可以修改，容易会引发灾难性的后果。</p>
<p>注意：长度非零的数组总是可变的。不要让类包含公有的静态 final 数组成员，或返回这个成员的访问方法。这往往是导致安全漏洞的根源之一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Potential security hole!</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Thing[] VALUES = &#123;...&#125;;<br></code></pre></td></tr></table></figure>
<p>正确的做法是使用私有数组成员，并提供一个公有的<code>List</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Thing[] PRIVATE_VALUES = &#123;...&#125;;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;Thing&gt; VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));<br></code></pre></td></tr></table></figure>
<p>或者返回一个数组的拷贝：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Thing[] PRIVATE_VALUES = &#123;...&#125;;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Thing[] values()&#123;<br>  <span class="hljs-keyword">return</span> PRIVATE_VALUES.clone();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>至于用哪种方法，取决于你自己的取舍。</p>
<h3 id="隐式访问级别"><a href="#隐式访问级别" class="headerlink" title="隐式访问级别"></a>隐式访问级别</h3><p>Java 9提供了两种新的隐式访问级别，作为<ruby>模块系统<rt>module system</rt></ruby>的一部分。一个模块就是一组包，模块可以通过其模块声明中的导出声明，显式地导出它的一部分包。未被导出的包在模块外是不可访问的。模块内部的访问性不受导出声明影响。</p>
<p>如果模块的JAR文件不在模块路径下，则其内部的包就会恢复非模块的访问级别。要充分利用模块的这一特性，可以将包集中到模块中，并在模块声明中显式地表明包之间的依赖关系，重新安排结构树，从模块内部处理对非模块化的包的任何访问。</p>
<p>总之，应该尽可能降低程序中所有元素的可访问性。</p>
<h2 id="16-在公有类中使用访问方法"><a href="#16-在公有类中使用访问方法" class="headerlink" title="16. 在公有类中使用访问方法"></a>16. 在公有类中使用访问方法</h2><p>有时候你可能需要编写一些退化类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span></span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> x;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> y;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这种类没有什么行为，单纯就是一些数据的集合。这样的设计非常不好——它没有提供任何封装。如果不改变API，就不能改变其内部数据表示，不能对数据施加任何约束，也不能在外部访问字段时采取任何操作。较好的做法应该是用<code>getter</code>和<code>setter</code>方法作为代替：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> y;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getX</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> x; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setX</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span> </span>&#123; <span class="hljs-keyword">this</span>.x = x; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getY</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> y; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setY</span><span class="hljs-params">(<span class="hljs-keyword">double</span> y)</span> </span>&#123; <span class="hljs-keyword">this</span>.y = y; &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>对于公有类，的确应该坚持<strong>面向对象编程</strong>的原则：如果类可以被其所有包之外的对象所访问，就应该提供<code>getter</code>方法，以保留将来改进内部表示的灵活性。不过对于包访问级别的类，直接暴露其数据域和私有并没有本质区别——而且可以保证你的代码不会过于凌乱。虽然这样一来，使用到该类的代码就会和该类紧密耦合，但这也仅限于包内部，其实无伤大雅。</p>
<p>Java类库中存在一些违反了“公有类不应暴露内部数据表示法“的类，如<code>Dimension</code>类和<code>Point</code>类，它们大都成为了绝佳的反面教材。</p>
<p>虽然直接暴露数据域绝非好事，但如果是不可变的字段，影响还是会稍微小一些。虽然你还是没法自由修改表示法，或采取辅助操作，但至少你可以强加约束。如下例所示，它确保了每个实例都表示一个有效的时间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Time</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> HOUR_PER_DAY = <span class="hljs-number">24</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MINUTES_PER_HOUR = <span class="hljs-number">60</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hour;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> minute;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Time</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hour, <span class="hljs-keyword">int</span> minute)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(hour&lt;<span class="hljs-number">0</span>||hour&gt;=HOUR_PER_DAY||minute&lt;<span class="hljs-number">0</span>||minute&gt;=MINUTES_PER_HOUR)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(String.format(<span class="hljs-string">&quot;hour:%s,minute:%s&quot;</span>,hour,minute));<br>        <span class="hljs-keyword">this</span>.hour = hour;<br>        <span class="hljs-keyword">this</span>.minute = minute;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="17-最小化可变性"><a href="#17-最小化可变性" class="headerlink" title="17. 最小化可变性"></a>17. 最小化可变性</h2><p>不可变类，就是其实例不能被修改的类，它所有的信息都必须在创建时被提供并在整个生命周期内保持不变。Java类库中有许多不可变类，如<code>String</code>类、基本类型的包装类、<code>BigInteger</code>类等。不可变类比可变类更易于设计、实现和使用，而且也不易出错，更加安全。</p>
<p>要使类成为不可变类，只需要遵循以下规则：</p>
<ol>
<li>不要提供任何会修改对象状态的方法（即设值方法）；</li>
<li>保证类不会被继续。这样可以防止恶意子类破坏其行为；</li>
<li>声明所有的字段为 final 的。通过系统强制方法来清楚地传达你的意图，同时也可以保证在缺乏同步机制时的线程安全性；</li>
<li>声明所有的字段为私有的。防止其他程序访问或修改内部引用的可变对象，同时也可以确保未来有改变其内部表示的灵活性。</li>
<li>确保对于任何可变组件的互斥访问。如果类持有指向可变对象的引用，确保这些引用永远不会被其他程序获取，也不要用其他程序提供的引用初始化这些字段，或提供任何指向它们的访问方法。在构造器、访问方法和<code>readObject</code>方法中使用<strong>保护性拷贝</strong>。</li>
</ol>
<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>下述代码实现了一个复数类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Immutable complex number class</span><br><span class="hljs-keyword">public</span> Final <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Complex</span></span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> re:<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> im<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Complex</span> <span class="hljs-params">(<span class="hljs-keyword">double</span> re,<span class="hljs-keyword">double</span> im)</span></span>&#123;<br>	  <span class="hljs-keyword">this</span>.re =re;<br>    <span class="hljs-keyword">this</span>.im =im;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">realPart</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">return</span> re; &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">imaginaryPart</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">return</span> im; &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Complex <span class="hljs-title">plus</span><span class="hljs-params">(Complex c)</span></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Complex(re+c.re,im+c.im); &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Complex <span class="hljs-title">minus</span> <span class="hljs-params">(Complex c)</span></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Complex (re-c.re,im-c.im)；&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Complex <span class="hljs-title">times</span> <span class="hljs-params">(Complex c)</span></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Complex(re * c.re,im * c.im); &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Complex <span class="hljs-title">dividedBy</span><span class="hljs-params">(Complex c)</span> </span>&#123;<br>    <span class="hljs-keyword">double</span> tmp = c.re * c.re + c.im * c.im;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Complex((re * c.re + im * c.im) / tmp, (im * c.re - re * c.im) / tmp);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span> <span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">this</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">if</span>(!(o <span class="hljs-keyword">instanceof</span> Complex)）<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    Complex c = (Complex) o；<br>    <span class="hljs-keyword">return</span> Double. compare(c.re, re) = <span class="hljs-number">0</span> &amp;&amp; Double. compare(c. im, im) == <span class="hljs-number">0</span>；<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">31</span> * Double.hashCode(re) + Double.hashCode(im); &#125;<br><br>  <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;(%f+%fi)&quot;</span>,re,im); &#125;<br></code></pre></td></tr></table></figure>
<p>它实现了四则运算：请注意四则运算是如何实现的。它们都创建了新的<code>Complex</code>实例并返回，而不是修改参与运算的对象。这种做法称为<strong>函数式编程</strong>，函数计算结果但不会改变参数的任何状态。在命名时，函数方法最好以介词（如 plus）而非动词（如 add）命名。<code>BigInteger</code>类就没有遵守这一命名习惯，结果导致了许多错误的使用出现。</p>
<h3 id="不可变类的优点"><a href="#不可变类的优点" class="headerlink" title="不可变类的优点"></a>不可变类的优点</h3><p>相比与可变对象，不可变对象具有唯一的状态。只要你确保构造器确定了正确的约束，那么你就能确保在其生命周期内对象都满足约束。相反的，可变对象有任意复杂的状态空间，需要付出大量的精力保证其满足约束。如果文档没有精确描述其状态如何转移，想要可靠地使用可变类是非常困难的，甚至不可能的。</p>
<ol>
<li><p>不可变类本质是线程安全的。不可变类没有同步要求，当多个线程并发访问这样的对象时，可以确保它不会被破坏。因此，不可变对象可以安全地在线程间共享。在设计不可变类的时候应该意识到这点，并鼓励其他程序尽量重用现用的实例，比如为频繁用到的值提供预定义的公有静态变量：（以<code>Complex</code>类为例）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Complex ZERO = <span class="hljs-keyword">new</span> Complex(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Complex ONE = <span class="hljs-keyword">new</span> Complex(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Complex I = <span class="hljs-keyword">new</span> Complex(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>
<p>甚至可以进一步拓展这种做法：在类中实现一个静态工厂，缓存起所有被频繁请求的实例。基本类型的包装类和<code>BigInteger</code>都实现了这样的静态工厂，从而大大降低了创建和销毁实例的成本。在设计不可变类时，可以优先考虑用静态工厂而不是构造器。此外，不可变类也不需要任何“保护性拷贝”，事实上它们根本不需要拷贝。不要为不可变类实现<code>clone</code>方法或提供拷贝构造器！</p>
</li>
<li><p>不可变对象的内部信息也是可以共享的。这点可能有些抽象，不妨举个例子：<code>BigInteger</code>类的内部实现是由一个<code>int</code>值来表示符号，并由一个<code>int</code>数组表示值。使用<code>BigInteger.negate()</code>方法会生成当前数的负值，它和原本的<code>BigInteger</code>共享同一个值数组，只有符号位是自己的。</p>
</li>
<li><p>不可变对象为其他对象提供了大量的构件。对于任何对象，如果你知道它内部的组件是不可变的，维护其约束都会轻松得多。</p>
</li>
<li><p>不可变对象直接地实现了<strong>失败原子性<sup><a href="#fn_2" id="reffn_2">2</a></sup></strong>。它们的状态永远不变，因而也就不存在可能不一致的临时状态。</p>
</li>
</ol>
<h3 id="不可变类的缺点"><a href="#不可变类的缺点" class="headerlink" title="不可变类的缺点"></a>不可变类的缺点</h3><p>不可变对象并非没有缺点。事实上它最大的缺点就是：每个状态都需要一个新的实例。如果你要执行一个多步骤的操作，每步都会产生一个新的对象，而且除了最终对象外其他中间对象都会被丢弃，这种情况下性能问题就会很严重。解决方法有两种：</p>
<ol>
<li>如果能够知道有哪些复杂的的多步操作，可以为这些步骤提供相应的操作，并在内部优化它们。比如<code>BigInteger</code>类就有一个辅助类用于加速幂运算。而且你不需要自己操作，只要调用方法就好。</li>
<li>如果不知道会有些什么操作，可以提供一个配套存在的可变类。这点上最有名的例子就是<code>String</code>类和它的好朋友<code>StringBuilder</code>类。</li>
</ol>
<h3 id="不可变类的设计方案"><a href="#不可变类的设计方案" class="headerlink" title="不可变类的设计方案"></a>不可变类的设计方案</h3><p>前文中谈到过可以将类设为 final 来防止继承。不过其实有一种更好的方法，就是把类的所有构造器都设为私有（或包访问级别），并提供静态工厂来代替构造器。这样一来，在包内部依然可以灵活地使用，但对于包外部的程序，这个类是事实上的 final 类。而且这样一来你还拥有了通过改善静态工厂来优化的可能，可谓一举多得。</p>
<p>当<code>BigInteger</code>被设计出来时，对于“不可变类必须不能被继承”的说法还没有得到广泛的理解……所以直到今天，你如果要使用不可信的<code>BigInteger</code>类，都必须对它进行检查以判断它是不是一个被修改过的子类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BigInteger <span class="hljs-title">safeInstance</span><span class="hljs-params">(BigInteger val)</span></span>&#123;<br>  <span class="hljs-keyword">return</span> val.getClass()==BigInteger.class?val:<span class="hljs-keyword">new</span> BigInteger(val.toByteArray());<br>&#125;<br></code></pre></td></tr></table></figure>
<p>本条目开头指出：应该没有任何方法可以修改不可变类。事实上这条规则应当表述为：没有任何方法可以使对象的状态产生外界可见的改变。为了性能可以稍作优化，比如在对象内部缓存一些代价高昂的操作的结果，只要对外界是不可见的就行了。不过这个时候就要说了，经过这样优化的类，如果要实现<code>Serializable</code>接口的话，就得提供一个显式的<code>readObject</code>或<code>readResolve</code>方法才行，或使用<code>ObjectOutputStream.writeUnshared</code>方法。否则可能遭到恶意攻击。在绝大部分时候，都不必为提供<code>setter</code>方法。即使类是可变的，也要尽可能地降低其可变性。谨记以下法则：</p>
<blockquote>
<p>除非有令人信服的理由，否则每个字段都应该是<code>private final</code>的</p>
</blockquote>
<p>与之对应的，构造方法应该创建完全初始化的对象，并建立起所有必要的约束关系。除非有令人信服的理由，否则不要额外提供一个初始化方法，更不要提供一个“重新初始化”方法。</p>
<h2 id="18-组合优于继承"><a href="#18-组合优于继承" class="headerlink" title="18. 组合优于继承"></a>18. 组合优于继承</h2><p>继承是实现代码复用强有力的武器之一，但它并非是最佳选择。在包内部使用继承是非常安全的，因为包内部的子类和父类的实现都控制在你自己的手上；对于为了继承而设计且有良好文档描述的类，继承它们也是非常安全的。但是，对普通的实现类进行跨越包边界的继承，是非常危险的。</p>
<p>与方法调用不同，继承打破了类的封装性。也即是说，子类的行为取决于父类中特定的实现细节，而父类的实现完全可以随发行版本变迁。因此，子类也必须跟着父类的更新而演变——除非父类是专门为了继承而设计的，而且有良好的文档说明。</p>
<h3 id="覆盖方法需谨慎"><a href="#覆盖方法需谨慎" class="headerlink" title="覆盖方法需谨慎"></a>覆盖方法需谨慎</h3><p>以下是一个示例程序，它继承了<code>HashSet</code>类，记录了自创建以来添加过的总元素数目：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InstrumentedHashSet</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">HashSet</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> addCount = <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InstrumentedHashSet</span><span class="hljs-params">()</span></span>&#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InstrumentedHashSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initCap,<span class="hljs-keyword">float</span> loadFactor)</span></span>&#123;<br>    <span class="hljs-keyword">super</span>(initCap,loadFactor);<br>  &#125;<br>  <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>&#123;<br>    addCount++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.add(e);<br>  &#125;<br>  <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span></span>&#123;<br>    addCount+=c.size();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.addAll(c);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAddCount</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> addCount;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>看起来似乎实现没有任何问题，对吧？但是当运行以下示例时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">InstrumentedHashSet&lt;String&gt; s = <span class="hljs-keyword">new</span> InstrumentedHashSet&lt;&gt;();<br>s.addAll(List.of(<span class="hljs-string">&quot;Snap&quot;</span>,<span class="hljs-string">&quot;Crackle&quot;</span>,<span class="hljs-string">&quot;Pop&quot;</span>));<br>System.out.println(s.getAddCount());<br></code></pre></td></tr></table></figure>
<p>我们期望它返回3. 但结果却是6. 为什么呢？因为在<code>HashSet</code>的内部，其<code>addAll</code>方法是通过多次调用<code>add</code>方法来实现的。虽然文档中并没有说明这点，但这毕竟属于实现细节，不提及是合理的。我们可以去掉覆盖的<code>addAll</code>方法，这个类当然就能正常运行了。但是问题是，这样一来，类的正常运行就取决于<code>HashSet</code>的<code>addAll</code>方法如何实现的。一旦<code>HashSet</code>的实现发生了改变，那我们的类可能就又出 bug 了。</p>
<p>你可能会说，我们可以完全覆盖<code>addAll</code>方法，不去调用父类的<code>addAll</code>方法。这样当然可以，也很稳妥，但是这样就要完全实现父类的方法，即使可能没有必要。而且，这样会消耗大量精力、容易出错，性能也得不到保障。而且有时候甚至是不可行的，因为子类无法访问父类的私有成员。</p>
<p>此外，另一个可能破坏子类行为地方在于，其继承的类可以会在后续的版本中获得新的方法。举例而言，你想要继承一个集合类，对所有添加的元素施加特定的约束：要实现这样一个类，只要覆写所有添加元素的方法就行了。但你所继承的类可能在后续版本中添加插入元素的新方法，而你没有覆盖这个方法——那么就会出错。这不是空想，事实上<code>HashTablet</code>和<code>Vector</code>就修正过几个这样的安全漏洞。</p>
<p>你可能会认为，如果不覆盖原有的方法，只增加新方法，就能避免上述问题。的确，扩展相对安全一些，但并非没有风险。如果父类在后续更新中添加了新的方法，而它恰好和你覆盖的方法签名相同（但返回类型不同）——那你的类就通不过编译。如果返回类型都相同了……那就是覆盖了原有的方法，又回到了上述的情况中。此外，自己实现的方法可能不符合父类的约定，因为在你实现自己的方法时父类还没有对应的约定！</p>
<h3 id="优先使用组合"><a href="#优先使用组合" class="headerlink" title="优先使用组合"></a>优先使用组合</h3><p>幸运地是，有一种方法可以避免以上所有问题：那就是不去扩展现有的类，而是把现有的类作为一个成员。这种设计方法被称为<strong><ruby>复合<rt>composition</rt></ruby></strong>。这样一来，新的类就成了现有类的一个包装类，它调用被包含的现有类中对应的方法，并返回其结果。这种模式被称为<strong>转发</strong>，新类中的方法被称为<strong>转发方法</strong>。这样的做法要稳当得多：</p>
<ul>
<li>它不依赖原有类的实现细节</li>
<li>即使原有类添加了新的方法，也不会影响新的类</li>
</ul>
<p>下面使用组合模式重写<code>InstrumentedHashSet</code>类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Instrumented</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ForwardingSet</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> addCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Instrumented</span><span class="hljs-params">(Set&lt;E&gt; s)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(s);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        addCount++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.add(e);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>        addCount+=c.size();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.addAll(c);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAddCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> addCount;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardingSet</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Set</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;E&gt; s;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ForwardingSet</span><span class="hljs-params">(Set&lt;E&gt; s)</span> </span>&#123;<span class="hljs-keyword">this</span>.s = s;&#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> s.size();&#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> s.isEmpty();&#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object o)</span> </span>&#123;<span class="hljs-keyword">return</span> s.contains(o);&#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> s.iterator();&#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object[] toArray() &#123;<span class="hljs-keyword">return</span> s.toArray();&#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;<span class="hljs-keyword">return</span> s.toArray(a);&#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<span class="hljs-keyword">return</span> s.add(e);&#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span> </span>&#123;<span class="hljs-keyword">return</span> s.remove(o);&#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> </span>&#123;<span class="hljs-keyword">return</span> s.containsAll(c);&#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<span class="hljs-keyword">return</span> s.addAll(c);&#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">retainAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> </span>&#123;<span class="hljs-keyword">return</span> s.retainAll(c);&#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> </span>&#123;<span class="hljs-keyword">return</span> s.removeAll(c);&#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;s.clear();&#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<span class="hljs-keyword">return</span> s.equals(o);&#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> s.hashCode();&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这种设计除了获得了健壮性之外，也拥有更多灵活性。从本质上讲，<code>InstrumentedSet</code>依然是一个<code>Set</code>，而且通过唯一一个接收<code>Set</code>类型参数的构造器，使得它成为了一个能够包装<code>Set</code>实例的并赋予它更多功能的<code>Set</code>类。这正是<strong>装饰者</strong>模式。</p>
<p>装饰者模式有许多的优点，不过它不适用于基于回调的框架：在回调框架中，对象传递自身的引用(this)，因此后续的调用会绕开包装类。</p>
<p>你可能会担心包装对性能的影响，不过在实践中，这并不构成很大问题。主要问题还是编写转发方法的过程较为琐碎，但只须为每个接口编写一次构造器，包装类就能通过包含该接口的包来获得。</p>
<h3 id="什么时候应该继承"><a href="#什么时候应该继承" class="headerlink" title="什么时候应该继承"></a>什么时候应该继承</h3><p>只有当子类是父类真正的<strong>子类型</strong>的时候才应当使用继承，也即是”is-a”的关系的时候。扪心自问，“B真的是一个A吗”？如果得到了否定的答案，就应当放弃继承的想法，改用组合实现并暴露出一个较小的接口：A本质上不是B的一部分，只是它的实现细节而已。</p>
<p>如果在该使用复合时不恰当地使用了继承，会不必要地暴露实现细节，并把你永远限制在最初的实现上，从而限死原先类的性能。更糟糕的是，客户端程序员能够直接访问这些实现细节，导致语义上的混淆（或更严重的后果）。最严重的情况下，客户端程序员可能会直接修改父类，从而破坏子类的约束情况。<code>Properties</code>类的实现就是一个反面教材。在最初的设计中，<code>Properties</code>只允许字符串作为键和值，但如果直接访问其底层的<code>HashTable</code>就能违反此约定。等到Java类库的设计者们发现这个问题时，为时已晚，因为已经有大量的实现依赖于使用非字符串的键和值了。</p>
<p>最后需要值得考虑的就是，对于正在继承的类，它的API中是否存在缺陷呢？如果采用继承机制会把父类中所有的缺陷都传播到子类中；而使用组合则允许你得以设计新的API来隐藏这些缺陷。</p>
<h2 id="19-设计继承并提供文档说明；或不允许继承"><a href="#19-设计继承并提供文档说明；或不允许继承" class="headerlink" title="19. 设计继承并提供文档说明；或不允许继承"></a>19. 设计继承并提供文档说明；或不允许继承</h2><p>对于专门为了继承而设计的类，在撰写文档时要注意以下事项：</p>
<h3 id="精确描述自用性"><a href="#精确描述自用性" class="headerlink" title="精确描述自用性"></a>精确描述自用性</h3><p>文档必须精确地描述覆盖每个类可能带来的后果。即，文档必须说明所有<strong>可覆盖</strong>的方法的<strong><ruby>自用性<rt>self-use</rt></ruby></strong>。</p>
<ul>
<li>对于所有的<code>public</code>或<code>protected</code>方法，你都需要指明：<ul>
<li>该方法调用了哪些可覆盖的方法</li>
<li>以何种顺序调用的</li>
<li>每个调用是如何影响后续过程的</li>
<li>在哪些情形下会调用可覆盖的方法</li>
</ul>
</li>
</ul>
<p>对于任何调用了可覆盖的方法的方法，在其注释的末尾应该要包含关于这些调用的描述信息，它们应当由 Javadoc 标签<code>@implSpec</code>开头，并会生成如下内容：”Implementation Requirements: …”。这段话将描述该方法的内部工作情况。下面这段描述摘自 <code>java.util.AbstractCollection</code>的注释：</p>
<blockquote>
<p>Removes a single instance of the specified element from this collection, if it is present (optional operation). More formally, removes an element <code>e</code> such that <code>Objects.equals(o, e)</code>, if this collection contains one or more such elements. Returns <code>true</code> if this collection contained the specified element (or equivalently, if this collection changed as a result of the call).</p>
<ul>
<li><p><strong>Specified by:</strong></p>
<p><code>remove</code> in interface <code>Collection&lt;E&gt;</code></p>
</li>
<li><p><strong>Implementation Requirements:</strong></p>
<p>This implementation iterates over the collection looking for the specified element. If it finds the element, it removes the element from the collection using the iterator’s remove method.Note that this implementation throws an <code>UnsupportedOperationException</code> if the iterator returned by this collection’s iterator method does not implement the <code>remove</code> method and this collection contains the specified object.</p>
</li>
</ul>
</blockquote>
<p>其中<strong>实现要求</strong>部分翻译如下：</p>
<blockquote>
<p>该实现遍历整个集合来查找指定的元素，若找到该元素，则调用迭代器的<code>remove</code>方法来移除该元素。注意：如果该集合的迭代器类没有实现<code>remove</code>方法，则会抛出<code>UnsupportedOperationException</code>异常。</p>
</blockquote>
<p>这份文档清晰地说明了覆盖<code>iterator</code>方法会如何影响<code>remove</code>方法的行为。尽管它没有遵守关于文档的那名著名的格言<sup><a href="#fn_3" id="reffn_3">3</a></sup>，但是没有办法——继承破坏了封装性，所以你必须描述清楚那些可能尚未被定义的实现细节。</p>
<h3 id="精心设计钩子"><a href="#精心设计钩子" class="headerlink" title="精心设计钩子"></a>精心设计钩子</h3><p>为了使别人能够更方便地编写子类，你需要精心挑选<code>protected</code>方法作为钩子，以方便对方设计自己的实现。钩子也可以是<code>protected</code>成员对象。例如，<code>java.util.AbstactList</code>提供了一个<code>removeRange</code>方法：</p>
<blockquote>
<p>protected void removeRange(int fromIndex, int toIndex);</p>
<p>Removes from this list all of the elements whose index is between <code>fromIndex</code>, inclusive, and <code>toIndex</code>, exclusive. Shifts any succeeding elements to the left (reduces their index). This call shortens the list by <code>(toIndex - fromIndex)</code>elements. (If <code>toIndex==fromIndex</code>, this operation has no effect.)</p>
<p>This method is called by the <code>clear</code> operation on this list and its subLists. Overriding this method to take advantage of the internals of the list implementation can <em>substantially</em> improve the performance of the <code>clear</code> operation on this list and its subLists.</p>
<ul>
<li><p>Implementation Requirements:</p>
<p>This implementation gets a list iterator positioned before <code>fromIndex</code>, and repeatedly calls <code>ListIterator.next</code> followed by <code>ListIterator.remove</code> until the entire range has been removed. <strong>Note: if <code>ListIterator.remove</code> requires linear time, this implementation requires quadratic time.</strong></p>
</li>
</ul>
</blockquote>
<p>为什么要向客户端程序员提供这个方法呢？注意文档中的实现要求：此方法在实现中获取处于<code>fromIndex</code>前一个位置的迭代器，并重复调用其<code>next</code>和<code>remove</code>方法直到移除整个范围。如果迭代器的<code>remove</code>方法实现是$o(N)$时间复杂度的，则该实现是$o(N^2)$时间复杂度的。</p>
<p>显然，提供这个方法作为钩子是为了方便客户端程序员实现快速删除区间元素的方法。</p>
<p>那么问题来了，应当暴露哪些字段/方法呢？并没有通用的法则，只能努力地发挥你的聪明才智，然后编写一些子类来测试。一方面，你不能暴露地太多以免过度破坏封装；另一方面，如果没暴露关键的成员，可能导致这个类压根没法被继承。唯一的测试方法就是<strong>编写子类</strong>。如果写起来非常痛苦，可能是遗漏了关键的成员；如果多个子类都用不上某个<code>protected</code>成员，那可能就可以把它设为私有。经验表明，编写3个子类就足以测试你的扩展类设计得怎么样了。此外你还得注意：</p>
<ul>
<li>以后每次发布这个类的更新之前都必须重新编写子类来测试</li>
<li>描述继承信息的特殊文档可能打乱正常的文档信息。</li>
</ul>
<h3 id="注意构造器"><a href="#注意构造器" class="headerlink" title="注意构造器"></a>注意构造器</h3><p>构造器决不能调用可能会被覆盖的方法。要知道，父类的构造器会先于子类的构造器被调用，因此子类覆盖的方法可能会被在构造器调用前被调用，从而导致错误的行为。试看以下例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Super</span></span>&#123;<br>  <span class="hljs-comment">//Broken - constructor invoke an overridable method</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Super</span><span class="hljs-params">()</span></span>&#123;overrideMe();&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">overrideMe</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Super</span></span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Instant instant;<br>  Sub()&#123;<br>    instant = Instant.now();<br>  &#125;<br>  <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">overrideMe</span><span class="hljs-params">()</span></span>&#123;System.out.println(instant);&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Sub sub = <span class="hljs-keyword">new</span> Sub();<br>    sub.overrideMe();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>程序第一次将会打印<code>null</code>，第二次才会打印日期。为什么？因为第一次调用时，子类中的<code>instant</code>对象还没被初始化。如果构造器调用了<code>instant</code>的任何方法，都会导致<code>NullPointerException</code>异常。构造器只有调用私有，final 或静态方法时才是安全的。</p>
<p>同样的，<code>Cloneable</code>和<code>Serializable</code>接口也有类似的特质，它们的实现也决不能调用可覆盖的方法，不管是直接还是<strong>间接</strong>。</p>
<p>如果你决定在一个为继承而设计的类中实现<code>Serializable</code>接口，就必须使其的<code>readResolve</code>和<code>writeReplace</code>成为<code>protected</code>的方法，而不是私有方法。这正是“为了允许继承而不得不承诺实现细节”的情形！</p>
<h3 id="真的需要继承吗"><a href="#真的需要继承吗" class="headerlink" title="真的需要继承吗"></a>真的需要继承吗</h3><p>由上可见，设计可继承类会对类造成许多限制。有时候你可以轻易地抉择，比如抽象类（一定需要继承），或是不可变类（一定不需要继承）。但其他情况呢？</p>
<p>对于普通的具体类，最佳做法是禁止继承。实现的方法有两种：</p>
<ol>
<li>声明其为 final 的；</li>
<li>把它的构造器都设为私有或包访问权限，并提供静态工厂来代替构造器；</li>
</ol>
<p>如果你的类已经实现了某个标准接口，那就大胆地让它不可被继承。需要为你的类添加更多功能的人可以使用装饰者模式，别忘了，组合优于继承！</p>
<p>如果你没有实现标准接口，而且可能需要从这儿继承，那你可以考虑消除这个类中所有可覆盖方法的自用性，比如说，把每个可覆盖方法的内容都移到一个私有的辅助方法里去。非常辛苦，所以最好谨慎考虑。</p>
<h2 id="20-接口优于抽象类"><a href="#20-接口优于抽象类" class="headerlink" title="20. 接口优于抽象类"></a>20. 接口优于抽象类</h2><p>Java 提供了两种机制实现多态：抽象类和接口。自从引入了<strong><ruby>默认方法<rt>default method</rt></ruby></strong>，这两种机制都可以为提供一些方法的实现。主要的区别在于，Java 只允许单继承，所以类只能成为<strong>一个</strong>抽象类的子类。相反，接口则无此限制——只要实现了接口中定义的方法就行了。</p>
<h3 id="接口的优点"><a href="#接口的优点" class="headerlink" title="接口的优点"></a>接口的优点</h3><ol>
<li><p>类可以实现新的接口</p>
<p>现有的类想要实现新的接口并没有任何限制。你只需要增加必要的方法，然后在声明末尾加上一个<code>implements</code>子句。当 Java 引入<code>Comparable</code>,<code>Iterable</code>和<code>Autocloseable</code>等接口时，许多原有的类都更新并应用上了这些接口。但是，想要继承自新的抽象类，这就很困难了。如果非要这样做不可，就得把抽象类放到继承层次的高处，让它成为你的类的共同祖先。这样不仅非常麻烦，而且会间接地破坏类的继承层次——原有类的所有后代都<strong>必须</strong>继承自这个抽象类，不管是否合适。</p>
</li>
<li><p>接口是混合类型的最佳实现</p>
<p><ruby>混合类型<rt>mixin</rt></ruby>，不严格地说，就是一个类除自己的“基本类型”外，还可以拥有的类型。比如，<code>Comparable</code>就是一个混合类型，它表明了对应的功能（排序）可以被混合到类的主要功能中。抽象类不能用来实现混合类型，因为类不能有多个父类，类的继承层次中也没地方可以插入混合类型。</p>
</li>
<li><p>接口允许构造非层次结构</p>
<p>并非所有事物都可以用层次结构来描述。例如，我们可以用一个接口来代表歌唱家，另一个代表作曲家：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Singer</span></span>&#123;<br>  <span class="hljs-function">AudioClip <span class="hljs-title">sing</span><span class="hljs-params">(Song song)</span></span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Songwriter</span></span>&#123;<br>  <span class="hljs-function">Song <span class="hljs-title">compose</span><span class="hljs-params">(<span class="hljs-keyword">int</span> chartPosition)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>而现实中有许多歌唱家同时也是作曲家。用接口实现，这完全没有问题，甚至可以添加一些新的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SingerSongwriter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Singer</span>,<span class="hljs-title">Songwriter</span></span>&#123;<br>  <span class="hljs-function">AudioClip <span class="hljs-title">strum</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">actSensitive</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>想想看用类要怎么实现吧：对于每一种属性的组合，都要用一个单独的类来实现，如果有 $n$ 个属性，那就得有 $2^n$ 种属性组合！而且随着层次的臃肿，类本身也会变得臃肿，因为在类的继承层次中并没有任何类型体现了公共的行为。</p>
</li>
<li><p>接口可以安全地增强类的功能</p>
<p>使用装饰者模式，把所有的类作为增强类的一个成员变量，并实现同一个接口，就能够安全地增强类的功能。相反，如果使用抽象类，就不得不使用继承来实现增强类，相比包装类，这样的做法更加脆弱，功能上也更差。</p>
</li>
</ol>
<h3 id="抽象骨架实现"><a href="#抽象骨架实现" class="headerlink" title="抽象骨架实现"></a>抽象骨架实现</h3><p>接口默认方法的实现有诸多限制：不允许提供<code>Object</code>方法的默认实现，不能包含实例成员以及非公有的静态成员，也不能给不是自己写的接口添加默认方法。不过，通过为接口添加一个<strong><ruby>抽象骨架实现<rt>skeletal implementation</rt></ruby></strong>类，就能结合接口和抽象类的优点。具体操作如下：</p>
<ul>
<li>接口定义类型，并实现部分默认方法</li>
<li>抽象骨架类实现通用的模板方法</li>
<li>具体的非通用方法由子类实现</li>
</ul>
<p>这就是模板方法模式！</p>
<p>按惯例，骨架类命名为 Abstract<em>Interface</em> 类，其中 <em>Interface</em> 是要实现的那个接口。例如，在 Java 的集合类库中，就为每一个重要的集合接口实现了对应的抽象骨架类，即<code>AbstractCollection</code>, <code>abstractSet</code>, <code>abstractList</code>和<code>abstractMap</code>. 如果设计得当，抽象骨架可以得程序员非常容易编写自己的接口实现类。例如以下就是一个<code>List</code>实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Concrete implementation built atop skeletal implementation</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title">intArrayAsList</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a)</span></span>&#123;<br>  Objects.requireNonNull(a);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AbastractList&lt;Integer&gt;()&#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>      <span class="hljs-keyword">return</span> a[i];<br>    &#125;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,Integer val)</span></span>&#123;<br>      <span class="hljs-keyword">int</span> oldVal=a[i];<br>      a[i]=val;<br>      <span class="hljs-keyword">return</span> oldVal;<br>    &#125;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-keyword">return</span> a.length;<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个例子是一个静态工厂，它通过匿名内部类的方式实现了一个<code>Adapter</code>，提供了一个<code>int</code>数组的 <code>List&lt;Integer&gt;</code>视图。不过，由于自动拆/装箱，它的性能不会太高。</p>
<p>抽象骨架类的优点在于，它既为接口实现类提供了实现上的帮助，又不强加约束。对于新编写的类，直接继承自抽象骨架类即可；如果是原有的类，也可以手工实现接口，而且依然会受益于接口中实现的默认方法。而且，即使只实现接口（不继承抽象骨架类），也可以把让一个内部私有成员继承抽象骨架类，并将对应的接口方法转发到这个成员上，这种做法称为<strong>模拟多重继承</strong>。这种方法拥有多重继承的绝大多数优点，又避免了对应的缺陷。</p>
<h3 id="编写抽象骨架的过程"><a href="#编写抽象骨架的过程" class="headerlink" title="编写抽象骨架的过程"></a>编写抽象骨架的过程</h3><p>首先，研究接口，并确定哪些方法是最基本的（基本方法必须由子类实现），并在抽象骨架中实现所有非基本方法。接下来，为所有不依赖基本方法的方法实现默认方法。如果基本方法和默认方法已经覆盖了所有方法，那你的任务就完成了——不需要抽象骨架了。否则还是得实现抽象骨架。记住，<code>Object</code>方法不能提供默认方法！</p>
<p>以<code>Map.Entry</code>接口为例，基本方法是<code>getKey</code>, <code>getValue</code>和<code>setValue</code>，同时还需要实现<code>equals</code>和<code>hashCode</code>方法。由于含有<code>Object</code>方法，因此所有实现都放在骨架中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractMapEntry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span>&#123;<br>  <span class="hljs-comment">//Entries in a modifiable map must override this method</span><br>  <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">setValue</span><span class="hljs-params">(V value)</span></span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOpoerationException();<br>  &#125;<br>  <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(o==<span class="hljs-keyword">this</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">if</span>(!(o <span class="hljs-keyword">instanceof</span> Map.Entry))<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    Map.Entry&lt;?,?&gt; e=(Map.Entry)o;<br>    <span class="hljs-keyword">return</span> Objects.equals(e.getKey(),<span class="hljs-keyword">this</span>.getKey())&amp;&amp;Objects.equals(e.getValue(),<span class="hljs-keyword">this</span>.getValue());<br>  &#125;<br>  <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> Objects.hashCode(<span class="hljs-keyword">this</span>.getKey())^Objects.hashCode(<span class="hljs-keyword">this</span>.getValue());<br>  &#125;<br>  <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getKey()+<span class="hljs-string">&quot;=&quot;</span>+<span class="hljs-keyword">this</span>.getValue();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>因为骨架实现类是为了继承的目的而被设计，所以应当遵守 19 条中所述的指导原则。对于抽象骨架类而言，文档是必须的。</p>
<p>有一个类似于抽象骨架的类，称为<strong><ruby>简单实现<rt>simple implementation</rt></ruby></strong>，它实现了接口，也是为继承而设计的，但是并不是抽象的。通常它是最简单的有效实现，可以供程序员直接使用，或是拿来继承。总而言之，一旦定义了一个接口，就应该考虑提供合适的抽象骨架实现，并在接口中尽可能地实现默认方法，以便接口的实现类能够利用。</p>
<h2 id="21-谨慎设计接口"><a href="#21-谨慎设计接口" class="headerlink" title="21. 谨慎设计接口"></a>21. 谨慎设计接口</h2><p>在 Java 8 之前，（如果不修改原有的类）接口是不能添加新的方法的。在 Java 8 版本之后，可以给接口添加默认方法，目的就是允许为现有的接口添加方法。默认方法的声明中包含一个默认实现，这是为所有没有覆盖默认方法的类使用的。尽管有默认方法，但并不代表它在之前存在的类中都能良好运行。要知道，在 Java 8 之前，可以默认接口<em>永远</em>也不会有新方法的。</p>
<p>Java 8 在集合类中添加了许多新的默认方法，主要是为了方便使用 lambda 表达式，尽管 Java 类库的默认方法都是高品质的通用实现，而且大部分情况下也能正常使用，但要记住：<strong>不存在适用于所有情况的默认方法</strong>。</p>
<p>举例而言，<code>Collection</code>接口在 Java 8 添加了一个<code>removeIf</code>方法，它遍历集合，检查条件并移除指定的元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Default method added to the Collection interface in Java 8</span><br><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeIf</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> E&gt; filter)</span></span>&#123;<br>  Objects.requireNonNull(filter);<br>  <span class="hljs-keyword">boolean</span> result=<span class="hljs-keyword">false</span>;<br>  <span class="hljs-keyword">for</span>(Iterator&lt;E&gt; it = iterator();it.hasNext();)&#123;<br>    <span class="hljs-keyword">if</span>(filter.test(it.next()))&#123;<br>      it.remove();<br>      result=<span class="hljs-keyword">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这是适用于<code>removeIf</code>的最佳通用实现，但在某些现实存在的<code>Collection</code>实现中会出错。例如，<code>org.apache.commons.collections4.Collection.SynchronizedCollection</code>类，是一个线程安全的集合类。在它更新并实现<code>removeIf</code>之前，将会继承其默认实现，而这个实现根本不会（也无法）保证其基本承诺：每一个方法调用都自动同步。一旦调用了这个方法，就可能导致各种异常。因此，维护人员必须覆盖默认的<code>removeIf</code>方法，并实现对应的同步操作。</p>
<p>默认方法的出现，使得编译时不会报错或警告，但运行时却出错的情形增加了。因此，应当尽量避免在接口中添加新的方法。不过，在设计接口时应当多用默认方法，它简化了接口的实现过程。同时要注意，也没有办法删除方法或修改方法的签名。</p>
<p>结论是，尽管有默认方法的存在，但设计接口时还是应当谨慎。或许接口发布之后也能纠正，但千万不要指望它！</p>
<h2 id="22-接口只用于定义类型"><a href="#22-接口只用于定义类型" class="headerlink" title="22. 接口只用于定义类型"></a>22. 接口只用于定义类型</h2><p>接口通常作为类型而定义，表明类具有某些特定的行为。为了其他目的而定义接口是不恰当的。</p>
<p>例如，有一种接口被称为常量接口，通常只包含静态的 final 成员，方便实现接口的类调用常量（免得还要再加上类名）。以下是一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Constant interface antipattern - do not use!</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PhysicalConstants</span></span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> AVOGADROS_NUMBER = <span class="hljs-number">6.022_140_857e23</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>常量接口是对接口的不良使用。类内部使用的常量应当是实现细节，而不应当泄露到公有 API 中。通常这些常量对于用户没有什么价值，反而会迷惑他们。更糟糕的是，即使未来的版本中不需要这些常量了，也必须继续使用，以保证兼容性。此外，对于所有实现了这个接口的类而言，这些常量也会污染它们的命名空间。</p>
<p>导出常量比较好的方法是：</p>
<ul>
<li>添加到某个现有的类或接口中（如<code>Integer.MAX_VALUE</code>）</li>
<li>使用枚举类型</li>
<li>使用不可实例化的工具类</li>
</ul>
<p>以下是用静态工具类重写的版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhysicalConstants</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">PhysicalConstants</span><span class="hljs-params">()</span></span>&#123;&#125;;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> AVOGADROS_NUMBER = <span class="hljs-number">6.022_140_857e23</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果只是不想类名的话，用静态导入不就好了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> PhysicalConstants.*;<br></code></pre></td></tr></table></figure>
<p>总之，接口只应当用来定义类型。不要用接口干别的事。</p>
<h2 id="23-层次优于标签类"><a href="#23-层次优于标签类" class="headerlink" title="23. 层次优于标签类"></a>23. 层次优于标签类</h2><p>有时候可能会遇到带有多种类型的类，它们包含一个用来表示类型的<em>标签</em>字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Tagged class - vastly inferior to a class hierarchy!</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Figure</span></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Shape</span></span>&#123;RECTANGLE,CIRCLE&#125;;<br>  <span class="hljs-keyword">final</span> Shape shape;<br>  <span class="hljs-comment">//only use when shape is RECTANGLE</span><br>  <span class="hljs-keyword">double</span> length;<br>  <span class="hljs-keyword">double</span> width;<br>  <span class="hljs-comment">//only use when shape is CIRCLE</span><br>  <span class="hljs-keyword">double</span> radius;<br>  <span class="hljs-comment">//constructor for rectangle</span><br>  Figure(<span class="hljs-keyword">double</span> length,<span class="hljs-keyword">double</span> width)&#123;<br>    <span class="hljs-keyword">this</span>.length=length;<br>    <span class="hljs-keyword">this</span>.width=width;<br>    <span class="hljs-keyword">this</span>.shape=RECTANGLE;<br>  &#125;<br>  <span class="hljs-comment">//constructor for circle</span><br>  Figure(<span class="hljs-keyword">double</span> radius)&#123;<br>    <span class="hljs-keyword">this</span>.radius=radius;<br>    <span class="hljs-keyword">this</span>.shape=CIRCLE;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">switch</span>(shape)&#123;<br>      <span class="hljs-keyword">case</span> RECTANGLE:<span class="hljs-keyword">return</span> length*width;<br>      <span class="hljs-keyword">case</span> CIRCLE:<span class="hljs-keyword">return</span> Math.PI*(radius*radius);<br>      <span class="hljs-keyword">case</span> <span class="hljs-keyword">default</span>:<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError(shape);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这种标签类有诸多缺点：</p>
<ul>
<li>充斥着模板代码（如枚举声明、标签字段和条件语句）</li>
<li>多个实现挤在一个类中，影响了可读性</li>
<li>所有类的字段都要放在一起，增加了内存占用</li>
<li>字段不能置为 final, 除非构造器初始化所有不相关的字段（添加更多垃圾代码）</li>
<li>必须借助于构造器设置标签，而且还得设置正确的字段，否则会运行失败</li>
<li>不能添加新的类型，除非修改源代码</li>
<li>实例的数据类型和类的类型没有任何关联</li>
</ul>
<p>总之，标签类<strong>过于冗长，效率低下，容易出错</strong>。</p>
<p>解决方案非常简单，就是使用继承层次，只须作出简单的改写即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Class hierarchy replacement for a tagged class</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Figure</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Figure</span></span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> radius;<br>  Circle(<span class="hljs-keyword">double</span> radius)&#123;<span class="hljs-keyword">this</span>.radius=radius;&#125;<br>  <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> Math.PI*(radius*radius);&#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Figure</span></span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> length;<br>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> width;<br>  Rectangle(<span class="hljs-keyword">double</span> length,<span class="hljs-keyword">double</span> width)&#123;<br>    <span class="hljs-keyword">this</span>.length=length;<br>    <span class="hljs-keyword">this</span>.width=width;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> length*width;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用层次结构几乎纠正了以上的所有的问题：</p>
<ul>
<li>代码简洁且清楚</li>
<li>每个实现都有自己的类，不受累于其他类</li>
<li>所有字段都是 final 的</li>
<li>所有抽象方法都确保有一个实现（不会因为遗漏 if 而出错）</li>
<li>需要时可以直接拓展，而不用修改源代码</li>
<li>每个类型都与自身的数据成员相关联，并能由程序员设置约束</li>
</ul>
<p>此外，继承层次还能增强灵活性，并有利于编译时的类型检查。假设你想要拓展一个正方形类，可以说是非常轻松了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Rectange</span></span>&#123;<br>  Square(<span class="hljs-keyword">double</span> side)&#123;<br>    <span class="hljs-keyword">super</span>(side,side);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这种做法还有额外的好处：可以反映正方形是特殊的矩形这一事实。</p>
<p>上述做法没有提供访问方法，是为了简洁起见。正常来说是要提供访问方法的。</p>
<p>总之，每当你想要编写个标签字段的时候，不妨想一想，能不能用继承层次来取代，或是重构到某个继承层次里去。</p>
<h2 id="24-静态内部类优于内部类"><a href="#24-静态内部类优于内部类" class="headerlink" title="24. 静态内部类优于内部类"></a>24. 静态内部类优于内部类</h2><p>内部类是指嵌套到其他类内部的类，主要有以下四种：</p>
<ul>
<li>静态内部类</li>
<li>普通内部类</li>
<li>匿名内部类</li>
<li>局部类</li>
</ul>
<p>除静态内部类外，其他都可以统称为内部类。</p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类是最简单的嵌套类，可以被看成是一个普通的类，只是“恰好”被声明在一个类的内部。它是外围类的一个静态成员，遵守其他静态成员的可访问性规则：可以访问外围类的静态成员，不能访问外围类的实例成员。同样的，如果它被声明为私有的，就只能在外围类的内部才能被访问。静态内部类的一种常用用法是作为外围类的公有辅助类。</p>
<p>私有的静态内部类还能作为外围类的一种组件存在。例如，<code>Map</code>实例的内部通常用一个<code>Entry</code>对象实现，对应于<code>Map</code>中的每个键值对。虽然<code>entry</code>和<code>map</code>关联，但引用<code>entry</code>方法并不需要访问对应的<code>map</code>实例。用内部类也不会出错，但会浪费时间和空间。</p>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类和静态内部类的唯一区别就在于没有<code>static</code>修饰，但它们的区别其实很大。内部类可以直接访问外围类的所有成员，每一个内部类的实例都隐式地持有其外围类实例的引用。内部类可以直接调用外围实例的方法，或使用<code>OuterClass.this</code>构造获得外围实例的引用。</p>
<p>因此，每当创建一个内部类的实例时，它就和特定的一个外围类关联了起来，而且这种关联关系是固定的，不可修改。这种关联关系自然是要占用空间，而且增加构造时间的。</p>
<p>内部类的一个常用用法是定义一个<code>Adapter</code>，它允许外部类的实例被视作另一个类的实例。例如，<code>Map</code>接口就往往用内部类来实现其集合视图，通常是由<code>keySet</code>, <code>entrySet</code>和<code>values</code>方法来实现的。类似的，<code>List</code>接口也使用内部类实现其迭代器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySet</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSet</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;<br>  <span class="hljs-comment">//...some methods</span><br>  <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyIterator();<br>  &#125;<br>  <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;<br>    <span class="hljs-comment">//...some class omitted</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果内部类不必访问任何外围实例的成员，则应当<strong>始终</strong>把它设为静态的。由于每个实例都包含一个额外的指向外围的引用，不仅会消耗时间和空间，而且会导致外围实例有时不会被垃圾回收，从而引发内存泄露（而且非常难以发现）。此外，如果要把内部类作为的公有/受保护成员导出 API 的话，就更需要谨慎考虑了：你不可能在不违反兼容性的情况下把内部类改成静态内部类！</p>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名类并不是外围类的一个成员。它通常不和其他成员一起声明，而且会在声明的地方实例化。它不能持有静态成员，只能持有常量成员<sup><a href="#fn_4" id="reffn_4">4</a></sup>。同时，匿名内部类受到诸多限制，它只能实例化一次，不能执行<code>instanceof</code>测试，也不能实现超过一个以上的接口或同时继承一个类并实现接口。而且也别写太长，因为它们一般都出现在表达式中。</p>
<p>过去匿名内部类是动态创建小型类和过程对象的最佳方式，但现在更好的方法是用 lambda 表达式。此外，它也可以用在静态工厂内部。</p>
<h3 id="局部类"><a href="#局部类" class="headerlink" title="局部类"></a>局部类</h3><p>局部类和普通的内部类一样，不过它们只有局部作用域。不过它们可以重复使用。</p>
<h2 id="25-一个源文件只有一个类"><a href="#25-一个源文件只有一个类" class="headerlink" title="25. 一个源文件只有一个类"></a>25. 一个源文件只有一个类</h2><p>Java 编译器允许你在一个文件里声明多个顶级类，但这并没有任何好处，甚至可能引发巨大的风险。如果在一个源文件中定义多个顶级类，可能会导致重复定义；而哪个定义会被用到，就取决于源文件被传给编译器的顺序！为了更好地说明，下面举个小例子：</p>
<p>有三个文件，一个是 Main.java:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Main.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    System.out.println(Utensil.NAME+Dessert.NAME);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>另一个是 Utensil.java, 它包含两个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Utensil.java</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Utensil</span></span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String NAME = <span class="hljs-string">&quot;pan&quot;</span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dessert</span></span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String NAME = <span class="hljs-string">&quot;cake&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>第三个文件则是 Dessert.java, 它的内容却是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Utensil</span></span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String NAME = <span class="hljs-string">&quot;pot&quot;</span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dessert</span></span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String NAME = <span class="hljs-string">&quot;pie&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果你侥幸用命令<code>javac Main.java Dessert.java</code>来编译程序，那么编译就会失败。但不巧你用了<code>javac Main.java Utensil.java</code>，则结果是<code>pancake</code>. 类似的，如果你用命令<code>javac Dessert.java Main.java</code>来编译，就会输出<code>potpie</code>. 程序的行为取决于源文件被传给编译器的顺序，就显然是不可取的。</p>
<p>正确的做法是把每个顶级类都放在一个单独的源文件中。如果你非要放在一个源文件里，可以用静态内部类。但千万不要把它们放在一个源文件里！否则，程序的行为可能会非常地不可控。</p>
<blockquote id="fn_1">
<sup>1</sup>. 子类可以在任意地方替换父类。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>. 失败的方法调用应当使对象处于调用前的状态。<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_3">
<sup>3</sup>. 好的文档应该描述这个方法<strong>做了什么</strong>，而不是<strong>怎么做到</strong>的。<a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_4">
<sup>4</sup>. 常量成员是 final 基本类型，或常量字符串<a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a>
</blockquote>
</div></article><div class="post-view__sidebar"><div class="sidebar"><div class="tocbot"><h2>Toc</h2><div class="toc__content"></div></div><h2>Links</h2><div class="sidebar__link"><ul><li><a target="_blank" rel="noopener" href="https://github.com/gloryalex">Github</a></li><li><a href="mailto:gloryxie@icloud.com">Mail</a></li><li><a href="/atom.xml">Rss</a></li></ul></div><h2>Archives</h2><div class="sidebar__archives"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a></li></ul></div><h2>Categories</h2><div class="sidebar__categories"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></li></ul></div><h2>Tags</h2><div class="sidebar__tags"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Effective-Java/" rel="tag">Effective Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EffectiveJava/" rel="tag">EffectiveJava</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HeadFirstServlet/" rel="tag">HeadFirstServlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaWeb/" rel="tag">JavaWeb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RegExp/" rel="tag">RegExp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Servlet/" rel="tag">Servlet</a></li></ul></div></div></div></div><div class="horizontal-line" style="height: 1px"></div><div class="main__bottom"><div class="pre-next"><a class="pre-button" href="/2021/10/05/Effective%20Java%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%B3%9B%E5%9E%8B/">四. 泛型</a><a class="next-button" href="/2021/04/14/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20Object%20%E6%96%B9%E6%B3%95/">二. Object 方法</a></div></div></div></div><div class="footer"><span>©️2019-2021 Designed By&nbsp;<strong><a target="_blank" rel="noopener" href="https://github.com/random-yang">RandomYang</a></strong> Powered By&nbsp;</span><strong><a target="_blank" rel="noopener" href="https://hexo.io">hexo</a></strong></div><div class="darkmode-mask" id="darkmode-mask"></div><div class="sidebar__button"></div></body></html>