<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=0"><meta name="description" content="四. 泛型 [ A-Grain-Of-Sands ] "><meta name="theme-color" content="#ebc65a"><title>四. 泛型 [ A-Grain-Of-Sands ] </title><style>@font-face {
  font-family: 'Abril Fatface';
  font-style: normal;
  font-weight: 400;
  src: local('Abril Fatface'), local('AbrilFatface-Regular'), url(data:font/woff2;base64,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) format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Abril Fatface';
  font-style: normal;
  font-weight: 400;
  src: local('Abril Fatface'), local('AbrilFatface-Regular'), url(data:font/woff2;base64,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BL3+M1K+NfPvjlJEHZTOrkYvtdprqx0Hka+W/IhsQoUJE0jsPVOhV2itgp3Wame8dsB73DeCOfp+FMSxp2At3aozP1zVQ/tmEpXdveum7kat3CaLXRcmTZHmOveMiqxSteCZOrGKmscOa9WycTUXtRFabrtts1Nb3e5qHtqWPMWtuEkMSdydcarhKoTcVXtBgujKwULbPFJvqywIzBjboUacECG6ajlIews5dBUMkJ/LYHa12gpRLEsBDAAA6raxOaTnbx4GG5J6hdn4twxT1DRvEQZvD6banOa3BbstVh48efHmw5cffwECBQkWIvK/LTbhIkSKEi1GrDjxEiRKkixFqjTpMmTKki1Hrjz5ChQqUqxEqTLlKlSqUq2e+hpoqJHGmmiqmeZhWGKoYfaZ7qXhxhtjnlWWxsBotw0xxWdfjDPDSEfc98l8q33z1XeLrXPKCeu10NJErZzR2kmnXXDWOee90sYVF12yQVsfTXLdVde088Y7o3TQXkedddLFQnb/qVGrq24cuuvhtZ5666WPfvraaZEB+htokLfe2+1GBDbalARuuueWzbbYboejttrmmBHW2O+AvUmRDMb6EEUsHHQoDskRjxRIiVRILev2qn1oaGpomZOB2z/jmn/eUk6tvaZda/5znbhPCguQ7wsEvd1strBI3OYR8ye01+ZO0jbH36oqKm37w90hl2v/wO5o3vIjtpoZx20H) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
</style><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><script src="https://cdn.bootcss.com/highlight.js/9.6.0/highlight.min.js" defer></script><script src="/js/paper.js" defer></script><script src="https://www.googletagmanager.com/gtag/js?id=xx-xxxxxxx-xx" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'xx-xxxxxxx-xx');</script><link rel="stylesheet" href="/css/tocbot.css"><script src="/js/tocbot.js" defer></script><script>window.addEventListener('DOMContentLoaded', () => {
  tocbot.init({
    // Where to render the table of contents.
    tocSelector: '.toc__content',
    // Where to grab the headings to build the table of contents.
    contentSelector: '.article__content',
    // Which headings to grab inside of the contentSelector element.
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    // For headings inside relative or absolute positioned containers within content.
    hasInnerContainers: true,
    orderedList: false,
    collapseDepth: 2,
  });
})</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
  }
});
MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
  }
});</script><link rel="preload" href="https://cdn.bootcss.com/highlight.js/9.6.0/styles/github.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.6.0/styles/github.min.css"><link rel="preload" href="https://fonts.googleapis.com/css?family=Abril+Fatface&amp;display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface&amp;display=swap"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="A-Grain-Of-Sands" type="application/atom+xml">
</head><body><div class="mask-border"></div><div class="head"><div class="head__inner"><h1><a href="/">A-Grain-Of-Sands</a></h1><p>a little site, a few techies</p></div></div><div class="paper-container"><div class="main"><div class="location-bar"><div class="line-1"><div class="horizontal-line" style="height: 3px"></div></div><div class="line-2"><div class="horizontal-line" style="height: 1px"></div></div><p class="text">四. 泛型</p><div class="switch-button"><input class="container_toggle" type="checkbox" id="switch" name="mode"><label for="switch">Toggle</label></div><div class="line-3"><div class="horizontal-line" style="height: 1px"></div></div></div><div class="main__2-col"><article class="post-view__article"><div class="article__infomation"><div class="posts-item"><h2 class="posts-item__title"><a href="">四. 泛型</a></h2><span class="post__date">2021-10-05</span><a href="/tags/Effective-Java/"><span class="post__tags">#Effective Java</span></a><a href="/tags/Java/"><span class="post__tags">#Java</span></a></div></div><div class="article__content"><p>本章探讨关于泛型的话题。泛型从 Java 5 开始成为语言的一部分，它保证了编译期的类型安全。本章告诉你如何最大限度地享用泛型带来的优势，又不至于为它所累。</p>
<span id="more"></span>
<h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><div class="table-container">
<table>
<thead>
<tr>
<th>术语</th>
<th>范例</th>
<th>条目</th>
</tr>
</thead>
<tbody>
<tr>
<td>参数化类型</td>
<td><code>List&lt;String&gt;</code></td>
<td>26</td>
</tr>
<tr>
<td>实际类型参数</td>
<td><code>String</code></td>
<td>26</td>
</tr>
<tr>
<td>泛型</td>
<td><code>List&lt;E&gt;</code></td>
<td>26, 29</td>
</tr>
<tr>
<td>形式类型参数</td>
<td><code>E</code></td>
<td>26</td>
</tr>
<tr>
<td>无限制通配符类型</td>
<td><code>List&lt;?&gt;</code></td>
<td>26</td>
</tr>
<tr>
<td>非泛型类型</td>
<td><code>List</code></td>
<td>26</td>
</tr>
<tr>
<td>受限类型参数</td>
<td><code>&lt;E extends Number&gt;</code></td>
<td>29</td>
</tr>
<tr>
<td>自限定类型参数</td>
<td><code>&lt;T extends Comparable&lt;T&gt;&gt;</code></td>
<td>30</td>
</tr>
<tr>
<td>受限通配符类型</td>
<td><code>List&lt;? extends Number&gt;</code></td>
<td>31</td>
</tr>
<tr>
<td>泛型方法</td>
<td><code>static &lt;E&gt; List&lt;E&gt; asList(E[] a)</code></td>
<td>30</td>
</tr>
<tr>
<td>类型类</td>
<td><code>String.class</code></td>
<td>33</td>
</tr>
</tbody>
</table>
</div>
<h2 id="26-请勿使用非泛型集合"><a href="#26-请勿使用非泛型集合" class="headerlink" title="26. 请勿使用非泛型集合"></a>26. 请勿使用非泛型集合</h2><p>泛型，就是声明中含有类型参数（用一对尖括号括起来的参数）的类或接口，例如<code>List&lt;E&gt;</code>。每个泛型类都对应了一个原始类，即不带泛型参数的类，比如<code>List</code>，它与<code>List&lt;E&gt;</code>相对应。非泛型类就是删除了所有泛型信息的泛型类，其存在意义是为了保证和 Java 5 之前代码兼容。</p>
<h3 id="保证类型安全！"><a href="#保证类型安全！" class="headerlink" title="保证类型安全！"></a>保证类型安全！</h3><p>如果使用非泛型集合，在集合中即使放入了错误的元素，也不会出错，至多是在编译时有一条小小的警告。但是你一旦试图从集合中取出错误的元素，就会立刻出错。依<code>Fail-Fast</code>原则，出错之后应当尽快发现（最好是在编译时就发现！）——出错位置太远就会使得调试非常困难。</p>
<p>例如，如果你直接使用原始类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Collection stamps = ...<br></code></pre></td></tr></table></figure>
<p>然后插入一个错误的元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">stamps.add(<span class="hljs-keyword">new</span> Coin());<br></code></pre></td></tr></table></figure>
<p>注意，即使在这时也会运行一切正常！直到你取出这个元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(Iterator i = stamps.iterator();i.hasNext();)&#123;<br>  Stamp stamp = (Stamp)i.next();<span class="hljs-comment">//Throws ClassCastException!</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用泛型可以轻松地解决问题。你只需要在类型声明中加入如下信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Collection&lt;Stamp&gt; stamps = ...;<br></code></pre></td></tr></table></figure>
<p>这时，编译器会<strong>保证</strong>集合中只包含正确的类型。如果插入了错误的元素，编译器会抛出一条错误信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">error: incompatible types: Coin cannot be converted to Stamp:<br>  c.add(<span class="hljs-keyword">new</span> Coin);<br>            ^<br></code></pre></td></tr></table></figure>
<p>从集合中取出元素时，编译器也会插入隐式的转换，确保转换成功。你可能会说，怎么会有人把<code>coin</code>插入<code>stamps</code>里面呢！但是现实中却经常会发生，比如把<code>BigInteger</code>插入到<code>BigDecimal</code>集合里。</p>
<p>的确，使用非泛型集合是合法的，但是你不应该这样做。如果这样做了，你就<strong>丢掉了泛型在安全性和描述性方面的所有优势</strong>。由于泛型出现在 Java 诞生后约20年，因此为了保证兼容性，Java 至今都支持原始类型集合，并采用<ruby>擦除<rt>erasure</rt></ruby>实现泛型。如果你需要允许集合插入任何元素，那么应当使用<code>List&lt;Object&gt;</code>这样的形式——它明确表明集合支持任何类型的对象。要知道，<code>List&lt;String&gt;</code>是<code>List</code>的一个子类，但并不是<code>List&lt;Object&gt;</code>的子类。因此，如果方法的参数是<code>List</code>，那么可以传入<code>List&lt;String&gt;</code>作为实参；但如果如果参数是<code>List&lt;Object&gt;</code>，你是不能传入<code>List&lt;String&gt;</code>的。所以，<strong>使用<code>List</code>这样的原始类型集合会丢掉类型安全性</strong>，但使用<code>List&lt;Object&gt;</code>这样的参数化类型则不会。</p>
<h3 id="无限制通配符"><a href="#无限制通配符" class="headerlink" title="无限制通配符"></a>无限制通配符</h3><p>有时候你可能不确定（或不在意）集合中的元素类型。比如说，你有两个<code>Set</code>，并且想统计它们的交集大小。如果你使用非泛型集合，可能会这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Use of raw type for unknown element type - don&#x27;t do this!</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numElementsInCommon</span><span class="hljs-params">(Set s1,Set s2)</span></span>&#123;<br>  <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(Object o:s1)&#123;<br>    <span class="hljs-keyword">if</span>(s2.contains(o))result++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个方法可以正常运行。但它使用了原始类型，这是非常危险的！安全的做法是使用无限制通配符，即<code>Set&lt;?&gt;</code>的形式，它表示集合可能持有任意类型的元素。它和原始类型最大的区别是：</p>
<ul>
<li>你可以放入任何类型的元素到原始类型的集合里，因此可能会破坏集合的约束条件</li>
<li>你不能放入除了<code>null</code>之外的任意元素到<code>Collection&lt;?&gt;</code>里，这时编译器会报错</li>
</ul>
<p>事实上，你不仅无法放入元素，甚至不能预测你会获得哪种类型的元素。如果无法接受这一限制，请考虑使用泛型方法或受限的通配符类型。</p>
<h3 id="例外"><a href="#例外" class="headerlink" title="例外"></a>例外</h3><p>这一规则有两种例外。</p>
<ol>
<li><p>在字面量类中必须使用原始类型。Java 不允许使用参数化类型获取类。也就是说，虽然<code>List.class</code>是合法的，但<code>List&lt;String&gt;.class</code>是不合法的。</p>
</li>
<li><p>由于泛型信息在运行时被擦除，所以在参数类型上使用<code>instanceof</code>操作符是非法的。但是可以用无限制通配符替代原始类型，这对<code>instanceof</code>方法不会产生任何影响。泛型使用<code>instanceof</code>的首选方法如下：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(o <span class="hljs-keyword">instanceof</span> Set)&#123;<br>  Set&lt;?&gt; s= (Set&lt;?&gt;)o;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总之，使用原始类型容易在运行时产生异常，因此尽量不要使用。</p>
<h2 id="27-消除类型检查警告"><a href="#27-消除类型检查警告" class="headerlink" title="27. 消除类型检查警告"></a>27. 消除类型检查警告</h2><p>泛型编程很容易遇到编译器的类型检查警告。有些很容易消除，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Set&lt;Lark&gt; exaltation = <span class="hljs-keyword">new</span> HashSet();<br></code></pre></td></tr></table></figure>
<p>编译器会细致地提醒你哪儿错了。然后只要使用菱形运算符<code>&lt;&gt;</code>稍加修改就好了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Set&lt;Lark&gt; exaltation = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br></code></pre></td></tr></table></figure>
<p>但是有些警告非常难以消除。尽管如此，还是应当<strong>尽可能地消除每一个类型检查警告</strong>。消除警告确保代码是类型安全的，这非常好。如果无法消除警告<strong>又可以证明引起警告的代码是类型安全的</strong>，只有在这种情况下你才可以加上<code>@SupperssWarning(&quot;unchecked&quot;)</code>注解来禁止这条警告。不要给自己错误的安全感！可能代码编译时一切正常，但运行时却抛出了一条<code>ClassCastException</code>错误。也不要忽略（而非禁止）确定是安全的警告。如果出现了真正的异常警告时，它可能会被淹没在警告的海洋里，而不能被你所发现。</p>
<p><code>SupperssWarning</code>注解可以用在任何粒度上，但建议<strong>始终在可能的最小范围内使用<code>SupperssWarning</code>注解</strong>。不要在整个类上使用！你可能会掩盖非常重要的错误。</p>
<p>如果你发现在长度不止一行的方法里使用了<code>SupperssWarning</code>注解，可以把它移到一个局部变量的声明里。例如，<code>ArrayList.toArray</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; T[] toArray(T[] a)&#123;<br>  <span class="hljs-keyword">if</span>(a.length&lt;size)&#123;<br>    <span class="hljs-keyword">return</span> (T[])Arrays.copyOf(elements,size,a.getClass());<br>  &#125;<br>  System.arrayCopy(elements,<span class="hljs-number">0</span>,a,<span class="hljs-number">0</span>,size);<br>  <span class="hljs-keyword">if</span>(a.length&gt;size)a[size]=<span class="hljs-keyword">null</span>;<br>  <span class="hljs-keyword">return</span> a;<br>&#125; <br></code></pre></td></tr></table></figure>
<p>你会发现编译器提示类型检查警告，发生在下面这行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> (T[])Arrays.copyOf(elements,size,a.getClass());<br>                          ^<br>required: T[]<br>found: Object[]<br></code></pre></td></tr></table></figure>
<p>不能把<code>SupperssWarning</code>放在<code>return</code>语句上，这是不合法的。但也不能把它放在整个方法上。正确的做法是声明一个局部变量保存返回值，并注解它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">/ Adding local variable to reduce scope of <span class="hljs-meta">@SuppressWarnings</span><br><span class="hljs-keyword">public</span> &lt;T&gt; T[] toArray (T[] a) &#123;<br>  <span class="hljs-keyword">if</span> (a.length ＜ size) &#123;<br>    <span class="hljs-comment">//This cast is correct because the array we&#x27; re creating</span><br>    <span class="hljs-comment">//is of the same type as the one passed in, which is TE].</span><br>    <span class="hljs-meta">@SupperssWarning(&quot;unchecked&quot;)</span> T[] result = (T[])Arrays.copyOf(elements,size,a.getClass());<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>  System.arrayCopy(elements,<span class="hljs-number">0</span>,a,<span class="hljs-number">0</span>,size);<br>  <span class="hljs-keyword">if</span>(a.length&gt;size)a[size]=<span class="hljs-keyword">null</span>;<br>  <span class="hljs-keyword">return</span> a;<br>&#125; <br></code></pre></td></tr></table></figure>
<p>每次使用<code>SupperssWarning</code>注解时，都要添加一条注释，说明为什么这样做是安全的。这可以帮助别人理解代码，也可以尽量减少别人修改代码后出错的概率。如果你发现很难写，不妨多加思考，最后你会明白为什么类型检查操作是很不安全的。</p>
<h2 id="28-List-优于数组"><a href="#28-List-优于数组" class="headerlink" title="28. List 优于数组"></a>28. List 优于数组</h2><p>数组和泛型集合相比有两个很大的不同。</p>
<h3 id="1-编译期类型检查"><a href="#1-编译期类型检查" class="headerlink" title="(1) 编译期类型检查"></a>(1) 编译期类型检查</h3><p>数组是 <strong><ruby>协变的<rt>covariant</rt></ruby></strong>，而泛弄是 <strong><ruby>可变的<rt>invariant</rt></ruby></strong>。这是什么意思呢？假设<code>Sub</code>类是<code>Super</code>的子类，那么</p>
<ul>
<li>对于数组而言，<code>Sub[]</code>是<code>Super[]</code>的子类</li>
<li>对于泛型集合而言，<code>List&lt;Sub&gt;</code>和<code>List&lt;Super&gt;</code>并没有任何父子关系</li>
</ul>
<p>你可能会认为泛型集合是有缺陷的。但事实上，数组才是有缺陷的。下面的代码可以成功编译：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Failed at runtime</span><br>Object[] objectArray = <span class="hljs-keyword">new</span> Long[<span class="hljs-number">1</span>];<br>objectArray[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;I don&#x27;t fit it!&quot;</span> <span class="hljs-comment">//Throws ArrayStoreException</span><br></code></pre></td></tr></table></figure>
<p>但如果你使用<code>List</code>，就根本不会有这个问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Won&#x27;t compile</span><br>List&lt;Object&gt; ol = <span class="hljs-keyword">new</span> ArrayList&lt;Long&gt;();<span class="hljs-comment">//Incompatible types</span><br>ol.add(<span class="hljs-string">&quot;I don&#x27;t fit it!&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>但是，无论如何你都不能把<code>String</code>放进<code>Long</code>集合里。但是，使用数组，你要在运行时都会发生错误；而<code>List</code>保证错误会在编译期发现。当然是越早发现错误越好！</p>
<h3 id="2-运行时类型擦除"><a href="#2-运行时类型擦除" class="headerlink" title="(2) 运行时类型擦除"></a>(2) 运行时类型擦除</h3><p>第二个区别在于，数组会保留信息，即使在运行时数组也能得知它们的元素所属类型。但泛型是使用擦除实现的，只有编译时能拥有类型信息，而运行时会被统一视为<code>Object</code>。这是为了兼容性，但是这也导致数组和泛型不能很好地混用。</p>
<p>创建泛型数组是非法的。你不能创建这些类型：<code>new List&lt;E&gt;[]</code>, <code>new List&lt;String&gt;[]</code>或<code>new E[]</code>。如果试图编译，程序会抛出一个<ruby>泛型数组创建错误<rt>generic array creation exception</rt></ruby>。下面试举一例，假如 Java 允许泛型数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Won&#x27;t compile</span><br>List&lt;String&gt;[] stringList = <span class="hljs-keyword">new</span> List&lt;String&gt;[<span class="hljs-number">1</span>]; <span class="hljs-comment">//(1)</span><br>List&lt;Integer&gt; intList = List.of(<span class="hljs-number">42</span>);             <span class="hljs-comment">//(2)</span><br>Object[] objects = stringList;                   <span class="hljs-comment">//(3)</span><br>objects[<span class="hljs-number">0</span>] = intList;                            <span class="hljs-comment">//(4)</span><br>String s = stringList[<span class="hljs-number">0</span>].get(<span class="hljs-number">0</span>);                 <span class="hljs-comment">//(5)</span><br></code></pre></td></tr></table></figure>
<p>由于运行时擦除，<code>List&lt;Integer&gt;[]</code>和<code>List&lt;String&gt;[]</code>数组的运行时类型都会是<code>List[]</code>。仔细分析，我们发现第 3 行的转换是合法的（因为数组是协变的），而且第 4 行也是合法的（因为它们的运行时类型一致）。事实上，直到第 5 行，JVM 将获取到的元素转换为<code>String</code>时才会抛出错误，而这一过程中泛型系统的类型安全得到了保证吗？没有！这意味着泛型系统的基本保证被违背了（泛型失去了意义）。因此，Java 不允许使用泛型数组。</p>
<p>从技术的角度讲，诸如<code>List&lt;String&gt;</code>或<code>List&lt;E&gt;</code>这样的类型被称为<strong><ruby>不可具体化<rt>non-reifiable</rt></ruby></strong>的类型。不可具体化的意思是它的运行时信息比编译期信息更少。唯一可以具体化的参数类型是无限制通配符，也就是<code>List&lt;?&gt;</code>这样的类型。你可以创建<code>List&lt;?&gt;[]</code>数组，虽然这种用法很罕见。不能把泛型和数组结合导致了许多问题，比如你不能把可变参数和泛型结合（可以使用<code>@SafeVarargs</code>注解解决这个问题）。</p>
<p>总之，为了避免这种情况，最好是优先使用集合类型<code>List&lt;E&gt;</code>来创建泛型数组。这样会损失一些性能（和简洁性），但可以换回更高的类型安全性和通用性。</p>
<p>下面举一个例子，实现一个选择器类，它持有一个集合，并能随机选取集合中的一个元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Chooser - a class badly in need of generics!</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chooser</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object[] choiceArray;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Chooser</span><span class="hljs-params">(Collection choices)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.choiceArray = choices;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">choose</span><span class="hljs-params">()</span></span>&#123;<br>    Random rand = ThreadLocalRandom.current();<br>    <span class="hljs-keyword">return</span> choiceArray[rand.nextInt(choiceArray.length)];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用这个类时，你每次都必须将<code>choose</code>方法的返回值从<code>Object</code>转成需要的类型；如果弄错了类型，就会在运行时抛出错误。将它改成泛型如何？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Chooser - won&#x27;t compile</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chooser</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> T[] choiceArray;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Chooser</span><span class="hljs-params">(Collection&lt;T&gt; choices)</span></span>&#123;<br>    choiceArray = choices.toArray();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>不巧，这个版本的代码没法通过编译！因为因为你不能把<code>Object[]</code>数组隐式转换成<code>T[]</code>数组。你会说，我可以强制转换啊！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">choiceArray = (T[])choices.toArray();<br></code></pre></td></tr></table></figure>
<p>不错，确实可以编译，但编译器会警告你：它无法保证运行时的类型安全性，因为程序在运行时不知道<code>T</code>的类型——类型信息会在运行时被擦除。你可以在注释中证明你是对的，并用一条注解禁止警告，但更好的做法是用<code>List</code>代替数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//List-based Chooser - typesafe</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chooser</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;T&gt; choiceList;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Chooser</span><span class="hljs-params">(Collection&lt;T&gt; choices)</span></span>&#123;<br>    choiceList = <span class="hljs-keyword">new</span> ArrayList(choices);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">choose</span><span class="hljs-params">()</span></span>&#123;<br>    Random rand = ThreadLocalRandom.current();<br>    <span class="hljs-keyword">return</span> choiceList.get(rand.nextInt(choiceList.size()));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个版本的代码稍微冗长一些，但可以保证运行时不会得到<code>ClassCastException</code>异常。总之，数组和列表有着截然不同的规则，所以最好不要把它们混合使用。</p>
<h2 id="29-优先考虑泛型"><a href="#29-优先考虑泛型" class="headerlink" title="29. 优先考虑泛型"></a>29. 优先考虑泛型</h2><p>使用 JDK 提供的集合方法并不难，但编写自己的泛型会比较困难，但值得为此花费时间学习。让我们先基于<code>Object</code>实现一个简单的（玩具）栈：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.EmptyStackException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span> </span>&#123;<br>   <span class="hljs-keyword">private</span> Object[] elements;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">16</span>;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Stack</span><span class="hljs-params">()</span> </span>&#123;<br>      elements = <span class="hljs-keyword">new</span> Object[DEFAULT_INITIAL_CAPACITY];<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(Obejct e)</span> </span>&#123;<br>      ensureCapacity();<br>      elements[size++] = e;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> EmptyStackException();<br>      Object result = elements[--size];<br>      elements[size] = <span class="hljs-keyword">null</span>;<span class="hljs-comment">//Eliminate obsolete reference</span><br>      <span class="hljs-keyword">return</span> result;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacity</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">if</span> (elements.length == size) &#123;<br>         elements = Arrays.copyOf(elements,<span class="hljs-number">2</span>*size+<span class="hljs-number">1</span>);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个类没有被参数化，不过，即使它已经被广泛使用了，我们依然可以安全地把它重构为泛型类。这并不会影响使用非参数化类型的客户端代码。</p>
<p>将类重构为泛型的第一步是找出类型参数，并添加到它的声明中。这个例子中的类型显然只有一个，就是栈中的类型，我们将它命名为<code>E</code>。</p>
<p>第二步是用这个类型参数替换所有的<code>Object</code>类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//won&#x27;t compile</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;<br>    <span class="hljs-keyword">private</span> E[] elements;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">16</span>;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Stack</span><span class="hljs-params">()</span> </span>&#123;<br>      elements = <span class="hljs-keyword">new</span> E[DEFAULT_INITIAL_CAPACITY];<br>   &#125;<br>   <span class="hljs-comment">//...more methods</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>等等，这段代码不能编译！错误如下：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><code class="hljs smali">Stack.java:8: generic<span class="hljs-built_in"> array </span>creation:<br>   elements =<span class="hljs-built_in"> new </span>E[DEFAU<span class="hljs-class">LT_INITIAL_CAPACITY];</span><br>              ^<br></code></pre></td></tr></table></figure>
<p>它是什么意思？你不能创建<strong>不可实化类型</strong>的数组。是的，如果你需要编写包含数组的泛型时，都会遇到这个问题。解决方案有两种：</p>
<ul>
<li>创建一个<code>Object</code>数组并将它转换成泛型数组类型。这种用法是安全的，但并非类型安全的，因此编译器会产生一条警告：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">elements = (E[])<span class="hljs-keyword">new</span> Object[DEFAULT_INITIAL_CAPACITY];<br></code></pre></td></tr></table></figure>
<p>   你必须确定你所有的未受检转换不会危及程序的整体类型安全性！所有相关的数组都应当被作为私有字段保存，而且绝不能泄露到类的外部。唯一导出元素的方法是<code>push</code>方法，它导出的类型为<code>E</code>，能够确保转换成功。</p>
<ul>
<li>将<code>elements</code>的类型从<code>E[]</code>迁移到<code>Object[]</code>类型。你依然需要类型转换，不过是在弹出元素时：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">E result = (E)elements[--size];<br></code></pre></td></tr></table></figure>
<p>   这种方法依然需要你自己确保转换是安全的，并在该未受检转换上使用注解禁止警告。</p>
<p>两种方法各有所长，第一种方法具有更强的可读性——数组类型<code>E[]</code>明确地表明了它只包含<code>E</code>实例，也更加简洁，避免了多次类型转换。而第二种方法则避免了<em>堆污染</em>，虽说在这种情况下并没有什么坏处。实践上通常采用第一种做法。</p>
<p>你可能会提出疑问，为什么不遵循上一条的建议（<code>List</code>优于数组）？事情是这样的，Java 并没有内建支持<code>List</code>, 因此很多情况下泛型类必须基于数组，比如<code>ArrayList</code>的实现；或者是性能考虑，比如<code>HashMap</code>也基于数组实现。</p>
<p>泛型确实有很多限制，不过相比让客户端自己去进行类型转换，使用泛型还是要好得多。只要时间允许，应当把所有的类都泛型化。</p>
<h2 id="30-优先考虑泛型方法"><a href="#30-优先考虑泛型方法" class="headerlink" title="30. 优先考虑泛型方法"></a>30. 优先考虑泛型方法</h2><p>和优先使用泛型类一样，在设计方法时，也应当优先使用泛型方法。<br>还是以一个例子开始吧，你现在正在编写一个合并<code>Set</code>的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set <span class="hljs-title">union</span><span class="hljs-params">(Set s1,Set s2)</span></span>&#123;<br>	Set result = <span class="hljs-keyword">new</span> HashSet(s1);<br>	result.addAll(s2);<br>	<span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>它可以编译通过，不过会警告你这个方法并不是类型安全的。要把它变成类型安全的方法，你需要指定参数和返回值的元素类型。类型参数的声明位置，位于方法的修饰符及其返回值之间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-function">Set&lt;E&gt; <span class="hljs-title">union</span><span class="hljs-params">(Set&lt;E&gt; s1,Set&lt;E&gt; s2)</span></span>&#123;<br>	Set&lt;E&gt; result = <span class="hljs-keyword">new</span> HashSet&lt;E&gt;(s1);<br>	result.addAll(s2);<br>	<span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>就是这么简单。而且现在它编译时没有警告了，因为它已经是一个类型安全的方法了。<br>这个方法的局限之处在于三个<code>Set</code>的类型需要完全一样。如果你需要更加灵活的泛型方法，你可以使用<strong>有限通配符类型</strong>来达到你的目的。</p>
<h3 id="泛型单例工厂"><a href="#泛型单例工厂" class="headerlink" title="泛型单例工厂"></a>泛型单例工厂</h3><p>有时候需要创建一个不可变但又适用于多种类型的对象。由于泛型是基于擦除实现的，所以可以复用同一个对象，但需要一个静态工厂方法来为不同的类型参数分为对象。这一模式称为泛型单例工厂，常用于函数对象，比如<code>Collections.reverseOrder</code>。<br>以恒等函数分发器为例吧，虽然其实标准库提供了<code>Function.identity</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Generic singleton factory pattern</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> UnaryOperator&lt;Object&gt; INDENTITY_FN = (t)-&gt;t;<br><span class="hljs-meta">@SuppressWarning(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">UnaryOperator&lt;T&gt; <span class="hljs-title">identityFunction</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">return</span> (UnaryOperator&lt;T&gt;)INDENTITY_FN;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果不加注解会产生警告：在编译器看来，对于任意类型T，<code>UnaryFunction&lt;Object&gt;</code>并不一定是<code>UnaryFunction&lt;T&gt;</code>。不过，这是一个恒等函数，它直接返回未被修改的参数，所以无论T的具体类型是什么，用它作为<code>UnaryFunction&lt;T&gt;</code>都是类型安全的。<br>以下是使用这个泛型单例的示例程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;\<br>	String[] strings = &#123;<span class="hljs-string">&quot;jute&quot;</span>,<span class="hljs-string">&quot;hemp&quot;</span>,<span class="hljs-string">&quot;nylon&quot;</span>&#125;;<br>	UnaryOperator&lt;String&gt; sameString = identityFunction();<br>	<span class="hljs-keyword">for</span>(String s:strings)&#123;<br>		System.out.println(sameString.apply(s));<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="递归类型限制"><a href="#递归类型限制" class="headerlink" title="递归类型限制"></a>递归类型限制</h3><p>通过包含类型参数本身的特定表达式，可以限制泛型的类型参数。在标准库中，它最为常见的用法是在<code>Comparable</code>接口中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(T o)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这一接口的限制在于，许多实现了<code>Comparable</code>接口的类只能与自身同类的元素进行比较。<br>有许多方法需要接收一组实现了<code>Comparable</code>接口的元素，并对集合进行排序、或是搜索其最大最小值。要完成这一系列操作，需要列表中的每一个元素都能互相比较。表达这种约束条件的方法如下所示：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Using a recursive type bound to express mutual comparability</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="hljs-function">E <span class="hljs-title">max</span><span class="hljs-params">(Collection&lt;E&gt; c)</span></span>;<br></code></pre></td></tr></table></figure><br>这一类型限制，即<code>&lt;E extends Comparable&lt;E&gt;&gt;</code>，多少让人感觉有些绕口。它表达的含义是“任意可以与自身进行比较的类型E”。<br>以下是一个使用该声明计算列表最大值的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="hljs-function">E <span class="hljs-title">max</span><span class="hljs-params">(Collection&lt;E&gt; c)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(c.isEmpty())&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Empty collection&quot;</span>);<br>  &#125;<br>  E result = <span class="hljs-keyword">null</span>;<br>  <span class="hljs-keyword">for</span>(E e:c)&#123;<br>    <span class="hljs-keyword">if</span>(result == <span class="hljs-keyword">null</span> || e.compareTo(result)&gt;<span class="hljs-number">0</span>)&#123;<br>      result = e;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这一方法在集合为空时抛出<code>IllegalArgumentException</code>错误。或许可以使用<code>Optional&lt;E&gt;</code>作为代替。</p>
<p>递归类型通配符并不常用，但如果能理解这种惯用法，以及<ruby>模拟自类型<rt>simulated selftype</rt></ruby>惯用法，将会大有好处。</p>
<h2 id="31-利用受限通配符提高API的灵活性"><a href="#31-利用受限通配符提高API的灵活性" class="headerlink" title="31. 利用受限通配符提高API的灵活性"></a>31. 利用受限通配符提高API的灵活性</h2><p>如前所述，类型参数是<ruby>不变<rt>invariant</rt></ruby>的。换而言之，对于任意类型<code>Type1</code>和<code>Type2</code>来说，<code>List&lt;Type1&gt;</code>和<code>List&lt;Type2&gt;</code>都不会有任何父子关系。这看起来有悖直觉，但很有实际价值。你可以把任意类型放进<code>List&lt;Object&gt;</code>中，但只能把字符串放进<code>List&lt;String&gt;</code>中。<code>List&lt;String&gt;</code>并不能做到<code>List&lt;Object&gt;</code>所能做到的任何事情，所以它并不是后者的一个子类。<br>不过有时候我们可能需要更多的灵活性。让我们来看一个<code>Stack</code>的例子：</p>
<h3 id="设计-Stack-的API"><a href="#设计-Stack-的API" class="headerlink" title="设计 Stack 的API"></a>设计 Stack 的API</h3><p>假定我们为堆栈设计了一个放进一堆元素的方法。设计如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushAll</span><span class="hljs-params">(Iterable&lt;E&gt; src)</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(E e:src)push(e);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个方法编译时正确无误，但是可能不如人意。如果你有一个<code>Stack&lt;Number&gt;</code>，并调用了<code>push(Integer)</code>，设想中这应当是可行的（因为<code>Integer</code>是<code>Number</code>的子类型）。因此从逻辑上说，下列方法应该是可行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Stack&lt;Number&gt; numberStack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>Iterable&lt;Integer&gt; integers = ...;<br>numbers.pushAll(integers);<br></code></pre></td></tr></table></figure>
<p>然而这是不可行的，因为<strong>参数化类型是不可变的</strong>！<br>解决方案是使用Java提供的一种特殊的参数化类型，称为有限通配符类型。<code>pushAll</code>的接口类型不应当是<code>Iterable&lt;E&gt;</code>接口，而是<code>Iterable&lt;E及其子类型&gt;</code>类型。在Java中，正确的表述应当是<code>Iterable&lt;? extends E&gt;</code>。现在让我们来修改一下<code>pushAll</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushAll</span><span class="hljs-params">(Iterable&lt;? extends E&gt; src)</span></span>&#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>现在就没有任何问题了。类似的，如果我们想设计一个<code>popAll</code>方法，也会遇到类似的问题。但是这回会有些不一样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">popAll</span><span class="hljs-params">(Collection&lt;E&gt; dst)</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(!isEmpty())&#123;<br>    dst.add(pop());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果我们想要把堆栈中所有结果都保存到一个<code>Collection&lt;Object&gt;</code>中，将会得到一个类似的错误，毕竟<code>Collection&lt;Object&gt;</code>并不是<code>Collection&lt;Number&gt;</code>。正确的描述是<code>Collection&lt;Number及其超类&gt;</code>。写法则是<code>Collection&lt;? super E&gt;</code>。让我们重写一下<code>popAll</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">popAll</span><span class="hljs-params">(Collection&lt;? <span class="hljs-keyword">super</span> E&gt; dst)</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(!isEmpty())&#123;<br>    dst.add(pop());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>为了保证最大的灵活性，应当在表示<strong>生产者或消费者</strong>的类型参数上使用通配符类型。如果某个入参既是生产者又是消费者就不用管了，因为它就是那个类型。<br>记住以下口诀：</p>
<blockquote>
<p>PECS 表示 Producer-extends, consumer-super.</p>
</blockquote>
<p>也就是说，如果参数是一个消费者，就应当使用<code>&lt;? super T&gt;</code>；如果参数是一个生产者，就应当使用<code>&lt;? extends T&gt;</code>。</p>
<h3 id="正确的通配符使用方法"><a href="#正确的通配符使用方法" class="headerlink" title="正确的通配符使用方法"></a>正确的通配符使用方法</h3><p>让我们基于PECS原则来改写一些之前的条目提到过的方法声明。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Chooser</span><span class="hljs-params">(Collection&lt;T&gt; choices)</span></span><br></code></pre></td></tr></table></figure>
<p>构造器用choice集合来生成类型T的值（并保存起来供后续使用），因此参数显然是一个生产者，应当使用extends通配符类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Chooser</span><span class="hljs-params">(Collection&lt;? extends T&gt; choices)</span></span>;<br></code></pre></td></tr></table></figure>
<p>这个声明和之前有区别吗？有。假定你有一个<code>List&lt;Integer&gt;</code>，想要把它放进<code>Function&lt;Number&gt;</code>进行初始化，这时这个新的构造器就能派上用场了。</p>
<p>类似的还有以下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-function">Set&lt;E&gt; <span class="hljs-title">union</span><span class="hljs-params">(Set&lt;E&gt; s1,Set&lt;E&gt; s2)</span></span>;<br></code></pre></td></tr></table></figure>
<p>在这个方法中s1和s2也都是生产者，所以应当使用extends通配符类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-function">Set&lt;E&gt; <span class="hljs-title">union</span><span class="hljs-params">(Set&lt;? extends E&gt; s1,Set&lt;? extends E&gt; s2)</span></span>;<br></code></pre></td></tr></table></figure>
<p>注意返回类型依然是<code>Set&lt;E&gt;</code>。<strong>不要使用通配符类型作为返回值</strong>，它会强制用户在客户端代码中使用通配符类型。正确的做法是使通配符类型对用户透明，接受方法应当接受的参数，拒绝应当拒绝的参数。如果你设计的类的使用者必须考虑通配符类型，其api会很容易出错。</p>
<blockquote>
<p>注意：在 Java 8 之前的版本，使用时要加上显式类型参数：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Set&lt;Number&gt; numbers = Union.&lt;Number&gt;union(integers, doubles);<br></code></pre></td></tr></table></figure></p>
</blockquote>
<p>接下来我们研究一下<code>max</code>函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 要求集合中所有元素都能互相比较</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E extends Comparable&lt;? <span class="hljs-keyword">super</span> E&gt;&gt; <span class="hljs-function">E <span class="hljs-title">max</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span></span><br></code></pre></td></tr></table></figure>
<p>这个声明应该是本书中最复杂的声明了。首先看一下参数<code>list</code>，它用于获取 T 实例，所以类型修改为<code>List&lt;? extends E&gt;</code>。对于<code>Comparable&lt;E&gt;</code>，其始终是消费者，因此使用时也应当优先指定为<code>Comparable&lt;? super E&gt;</code>类型。使用<code>Comparator&lt;T&gt;</code>接口时也一样，应当优先使用<code>Comparable&lt;? super T&gt;</code>接口。</p>
<p>修改之后的比较接口能够接受没有直接实现Comparable接口，而是通过实现了其子接口的类（在原本的版本中会抛出错误）。</p>
<h3 id="类型参数与通配符之间的双重性"><a href="#类型参数与通配符之间的双重性" class="headerlink" title="类型参数与通配符之间的双重性"></a>类型参数与通配符之间的双重性</h3><p>很多方法可以同时使用类型参数和通配符来声明。像是如下两个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(List&lt;E&gt; list, <span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(List&lt;?&gt; list, <span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span>;<br></code></pre></td></tr></table></figure>
<p>两种方法哪种更好呢？在公共api中，第二种会更好一些，因为它更加简单。一般来说，如果类型参数在方法声明中只出现一次，那么就只可以用通配符替代它。如果是无限制的类型参数，就用无限制的通配符替代它；如果是有限制的类型参数，就使用有限制的通配符替代它。</p>
<p>但是如果把第二种声明应用于<code>swap</code>方法会引发一些问题。以下这个简单的实现将不能通过编译：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(List&lt;?&gt; list, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>	list.set(i,list.set(j, list.get(i)));<br>&#125; <br></code></pre></td></tr></table></figure><br>问题出在哪？出在<code>list.set(j,list.get(i))</code>这行上。从<code>list</code>刚取出的元素竟然不能放进<code>list</code>吗？是的。因为<code>list</code>的类型为<code>list&lt;?&gt;</code>，它不能放入除了 null 之外的任何元素。更为合适的实现是使用一个辅助的泛型方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(List&lt;?&gt; list,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span>&#123;<br>	swapHelper(list, i, j);<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swapHelper</span><span class="hljs-params">(List&lt;E&gt; list, <span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span>&#123;<br>	list.set(i,list.set(j, list.get(i)));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样的实现就能导出 swap 的更为简单的api，同时保证类型的正确性。注意到辅助方法所使用的签名，正是我们因为复杂而放弃的那个签名！</p>
<p>总而言之，对于库函数的编写者而言，虽然通配符的使用需要相当的技巧，但也会非常有用。</p>
<h2 id="32-泛型和可变参数放在一起时要小心"><a href="#32-泛型和可变参数放在一起时要小心" class="headerlink" title="32. 泛型和可变参数放在一起时要小心"></a>32. 泛型和可变参数放在一起时要小心</h2><p>可变参数的作用在于让客户端能够将可变数量的参数传给方法，但这是个<ruby>技术露底<rt>leaky abstration</rt></ruby>。调用一个可变参数的方法时，会生成一个数组来保存参数。这原本是个实现细节，但却泄露给了使用者。因此，当可变参数带有泛型或参数化类型时，就会导致编译错误警告混乱。</p>
<p>之前曾经谈及过<ruby>非具体化类型<rt>non-reifiable</rt></ruby>，即运行时代码比编译时少的类型。显然，泛型和参数类型都是非具体化类型。如果一个方法声明其可变参数为非具体化类型，编译器会产生一条错误，类似于：</p>
<blockquote>
<p>Possible heap pollution from parameterized vararg type list<String>.</p>
</blockquote>
<p>它的意思是，当一个参数化类型的变量指向一个不是该类型的对象时，可能会产生堆污染，会导致编译器的自动生成转换失败，从而违背泛型系统的基本保证。</p>
<p>举个例子，以下代码会产生<code>ClassCastException</code>异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dangerous</span><span class="hljs-params">(List&lt;String&gt;... stringList)</span></span>&#123;<br>	List&lt;Integer&gt; intList = List.of(<span class="hljs-number">42</span>);<br>	Object[] objects = stringLists;<br>	Object[<span class="hljs-number">0</span>] = intList;<br>	String s = stringList[<span class="hljs-number">0</span>].get(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在最后一行代码中，编译器会隐式地插入一条转换，正是这条转换触发了<code>ClassCastException</code>。从根本上说，原因在于创建了一个泛型数组，而泛型数组在 Java 中原本是不允许（显式地）创建的。为什么允许在可变参数中创建泛型数组呢？因为<strong>带有泛型或参数化类型的可变参数数在实践中具有巨大的作用</strong>，所以 Java 容许这一矛盾的存在。在 Java 7 中新增了<code>@SafeVararg</code>注解，用于消除泛型可变参数方法的编译器警告。换而言之，此注解向用户承诺方法是<strong>类型安全</strong>的。</p>
<p>现在的问题是，作为设计者，我们如何设计出<strong>真正</strong>类型安全的方法呢？由于泛型方法是在调用时创建的，用来保存可变参数，所以我们只要确保数组中所有保存任何新的值，也没有其他的引用（被不安全的代码访问），那我们就可以保证它是安全的。</p>
<p>即使数组中不去保存新的值也可能会导致不可预料的错误。以下方法会返回泛型可变参数的数组，乍一看似乎是一个便利的工具方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &lt;T&gt; T[] toArray(T...args)&#123;<br>        <span class="hljs-keyword">return</span> args;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>接下来是一个随机选择两个参数的泛型方法以及调用它的主方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &lt;T&gt; T[] pickTwo(T a,T b, T c)&#123;<br>    <span class="hljs-keyword">switch</span> (ThreadLocalRandom.current().nextInt(<span class="hljs-number">3</span>))&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<span class="hljs-keyword">return</span> toArray(a,b);<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-keyword">return</span> toArray(a,c);<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<span class="hljs-keyword">return</span> toArray(b,c);<br>        <span class="hljs-keyword">default</span>:<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError();<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String[] result = pickTwo(<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>看起来也没有任何问题。所有方法中都不包含显式的类型转换，而且也只是简单地从一个<code>String[]</code>中取出两项形成一个新的<code>String[]</code>。然而当你运行它时，系统会抛出一个<code>ClassCastException</code>错误。</p>
<p>原因在于，运行时虚拟机没有足够的信息来获取具体的参数类型，因此<code>toArray</code>方法返回的一定是一个<code>Object[]</code>，将它转换为<code>String[]</code>会失败。传出可变参数数组会导致堆污染传染到调用栈，所以一定要小心。确保只有在以下两种情况才能传出：</p>
<ul>
<li>调用方法是另一个<code>@SafeVarargs</code>方法</li>
<li>调用方法是非可变参数的函数式方法</li>
</ul>
<p>至于何时应当使用<code>@SafeVarargs</code>方法倒是非常简单：对于所有带有泛型或参数化类型的可变参数方法，都要用<code>@SafeVarargs</code>注解。否则你的方法的所有使用者都会受到编译器警告的折磨。</p>
<p>由于不能确保方法被覆盖之后依然安全，所以<code>@SafeVarargs</code>只能用在静态方法，或是用<code>private</code>或<code>final</code>修饰过的方法上。或者你也可以使用<code>List</code>参数来显式指定可变参数，就是会让你的使用者写起来有些烦琐（当然也会降低性能）。就像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// List as typesafe alternative to a generic varargs parameter</span><br><span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">flatten</span><span class="hljs-params">(List&lt;List&lt;? extends T&gt;&gt; lists)</span></span>&#123;...&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>	audience = flatten(List.of(friends, romans, countrymen));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这种做法的优势在于可以让编译器来保证类型安全，缺点则是性能以及使用者的体验。如果你的方法无法保证可变参数的类型安全性（例如前述的<code>toArray</code>），也可以转而使用这种方法。</p>
<p>总之，如果要使用泛型可变参数，确保：</p>
<ul>
<li>没有在可变参数数组中保存任何值；</li>
<li>没有让不受信任的代码获得该数组（或<code>clone</code>）的引用；</li>
</ul>
<p>这样你就能确保安全了。</p>
<h2 id="33-优先考虑类型安全的异构容器"><a href="#33-优先考虑类型安全的异构容器" class="headerlink" title="33. 优先考虑类型安全的异构容器"></a>33. 优先考虑类型安全的异构容器</h2><p>泛型常用于集合，而且通常是参数化了的容器，比如<code>Map&lt;K,V&gt;</code>， <code>List&lt;T&gt;</code>, <code>ThreadLocl&lt;E&gt;</code>等。这种情况下，容器中元素的类型是唯一的。</p>
<p>大部分情况下这都够用。但是有时候可能需要更多灵活。例如，数据库的行可以有任意数量的列，能不能以类型安全的方式访问所有列呢？幸运的是，有一种方式可以：</p>
<ol>
<li>把键进行参数化，而不是容器；</li>
<li>然后将参数化后的键提供给容器来进行插入或取值；</li>
<li>用泛型系统保证值的类型与键匹配。</li>
</ol>
<p>说起来有些抽象，让我们来看一个具体些的例子。</p>
<h3 id="Favorite-容器"><a href="#Favorite-容器" class="headerlink" title="Favorite 容器"></a>Favorite 容器</h3><p>我们现在设计了一个 Favorite 类，它可以让用户保存指定类型的“最喜欢的”对象。使用类的类型作为键，最喜欢的对象作为值。当使用类的字面量传达编译时及运行时信息时，称为<ruby>类型令牌<rt>type token</rt></ruby>。</p>
<p>Favorite 类的 API 设计非常简单，就像一个普通的映射。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Favorites</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">putFavorite</span><span class="hljs-params">(Class&lt;T&gt; type, T instance)</span></span>;<br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getFavorit</span><span class="hljs-params">(Class&lt;T&gt; type)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Favorite 实例是类型安全的，因为当你指定要求<code>String</code>时，它一定不会返回<code>Integer</code>给你；但它也是异构的，因为它所有键和值的类型都互不相同。这样的容器称为类型安全的异构容器。</p>
<p>它的完整实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Favorites</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Map&lt;Class&lt;?&gt;,Object&gt; favorites = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">putFavorite</span><span class="hljs-params">(Class&lt;T&gt; type, T instance)</span></span>&#123;<br>        favorites.put(Objects.requireNonNull(type),instance);<br>    &#125;<br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getFavorite</span><span class="hljs-params">(Class&lt;T&gt; type)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> type.cast(favorites.get(type));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>由于它的键的类型都带有不同的类型参数，所以互不相同。但其值都是<code>Object</code>类型。Map 并不能保证每个值都是其键所指定的类型 —— java 的类型系统并不足以表达这点。但我们知道这点，并在类的设计中用到了。虽然在<code>putFavorite</code>方法中我们失去了键和值的类型关联，但在<code>getFavorite</code>中重新建立了联系。cast 方法检测参数是否为类型<br>的实例，如果是就返回参数；否则抛出<code>ClassCastException</code>异常。但我们知道，如果正常使用，永远也不会抛出这个异常。</p>
<p>Favorite 类有两个局限性。</p>
<p>一是如果以原生形式的参数（即未加类型参数的 Class 对象）调用，就会导致客户端代码产生未受检警告。想要避免这一点可以在<code>put</code>方法里加入检查：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Achieving runtime type safety with a dynamic cast</span><br><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">putFavorite</span><span class="hljs-params">(Class&lt;T&gt; type, T instance)</span></span>&#123;<br>        favorites.put(type,type.cast(instance));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>类库中也有一些类似的技巧，例如<code>checkedSet</code>等集合的设计。它们会在自身的静态工厂构造方法里加入 Class 参数确保类型相匹配。这些类很适合用在泛型和原生类型混用的代码里。</p>
<p>第二个局限性在于它不能用于不可具体化的类型中。因为所有的不可具体化的类型在运行期都没有类型参数，也就是说不论是<code>List&lt;String&gt;</code>还是<code>List&lt;Integer&gt;</code>在运行期都是<code>List</code>。这会导致 Favorite 实例为<code>List&lt;String&gt;</code>和<code>List&lt;Integer&gt;</code>返回相同的对象，并会互相顶替。在 Java 中，List<String>.Class甚至是个语法错误。因此，没有什么比较好的解决方案。</p>
<p>如果需要有限制的类型令牌，可以使用受限类型参数来实现。Java 的注解 API 就充分利用了受限类型令牌，事实上被注解的元素就成为了一个类型安全的异构容器，容器的键是注解类型。以下是读取类注解的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T extends Annotation&gt; <span class="hljs-function">T <span class="hljs-title">getAnnotation</span><span class="hljs-params">(Class&lt;T&gt; annotationType)</span></span>;<br></code></pre></td></tr></table></figure>
<p>如果你有一个<code>Class&lt;?&gt;</code>，想把它传给<code>getAnnotation</code>使用，可以使用<code>asSubclass</code>这个安全的动态方法（而不是使用强制转换）。</p>
<p>总之，通过把类型放在键上，就可以避开一般容器要求固定类型参数的限制了。</p>
<h1 id="笔记-Java"><a href="#笔记-Java" class="headerlink" title="笔记 #Java"></a>笔记 #Java</h1></div></article><div class="post-view__sidebar"><div class="sidebar"><div class="tocbot"><h2>Toc</h2><div class="toc__content"></div></div><h2>Links</h2><div class="sidebar__link"><ul><li><a target="_blank" rel="noopener" href="https://github.com/gloryalex">Github</a></li><li><a href="mailto:gloryxie@icloud.com">Mail</a></li><li><a href="/atom.xml">Rss</a></li></ul></div><h2>Archives</h2><div class="sidebar__archives"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a></li></ul></div><h2>Categories</h2><div class="sidebar__categories"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></li></ul></div><h2>Tags</h2><div class="sidebar__tags"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Effective-Java/" rel="tag">Effective Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EffectiveJava/" rel="tag">EffectiveJava</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HeadFirstServlet/" rel="tag">HeadFirstServlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaWeb/" rel="tag">JavaWeb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RegExp/" rel="tag">RegExp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Servlet/" rel="tag">Servlet</a></li></ul></div></div></div></div><div class="horizontal-line" style="height: 1px"></div><div class="main__bottom"><div class="pre-next"><a class="pre-button">没有更多</a><a class="next-button" href="/2021/05/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/">三. 类和接口</a></div></div></div></div><div class="footer"><span>©️2019-2021 Designed By&nbsp;<strong><a target="_blank" rel="noopener" href="https://github.com/random-yang">RandomYang</a></strong> Powered By&nbsp;</span><strong><a target="_blank" rel="noopener" href="https://hexo.io">hexo</a></strong></div><div class="darkmode-mask" id="darkmode-mask"></div><div class="sidebar__button"></div></body></html>