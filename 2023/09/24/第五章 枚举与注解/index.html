<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=0"><meta name="description" content="五. 枚举与注解 [ A-Grain-Of-Sands ] "><meta name="theme-color" content="#ebc65a"><title>五. 枚举与注解 [ A-Grain-Of-Sands ] </title><style>@font-face {
  font-family: 'Abril Fatface';
  font-style: normal;
  font-weight: 400;
  src: local('Abril Fatface'), local('AbrilFatface-Regular'), url(data:font/woff2;base64,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) format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Abril Fatface';
  font-style: normal;
  font-weight: 400;
  src: local('Abril Fatface'), local('AbrilFatface-Regular'), url(data:font/woff2;base64,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BL3+M1K+NfPvjlJEHZTOrkYvtdprqx0Hka+W/IhsQoUJE0jsPVOhV2itgp3Wame8dsB73DeCOfp+FMSxp2At3aozP1zVQ/tmEpXdveum7kat3CaLXRcmTZHmOveMiqxSteCZOrGKmscOa9WycTUXtRFabrtts1Nb3e5qHtqWPMWtuEkMSdydcarhKoTcVXtBgujKwULbPFJvqywIzBjboUacECG6ajlIews5dBUMkJ/LYHa12gpRLEsBDAAA6raxOaTnbx4GG5J6hdn4twxT1DRvEQZvD6banOa3BbstVh48efHmw5cffwECBQkWIvK/LTbhIkSKEi1GrDjxEiRKkixFqjTpMmTKki1Hrjz5ChQqUqxEqTLlKlSqUq2e+hpoqJHGmmiqmeZhWGKoYfaZ7qXhxhtjnlWWxsBotw0xxWdfjDPDSEfc98l8q33z1XeLrXPKCeu10NJErZzR2kmnXXDWOee90sYVF12yQVsfTXLdVde088Y7o3TQXkedddLFQnb/qVGrq24cuuvhtZ5666WPfvraaZEB+htokLfe2+1GBDbalARuuueWzbbYboejttrmmBHW2O+AvUmRDMb6EEUsHHQoDskRjxRIiVRILev2qn1oaGpomZOB2z/jmn/eUk6tvaZda/5znbhPCguQ7wsEvd1strBI3OYR8ye01+ZO0jbH36oqKm37w90hl2v/wO5o3vIjtpoZx20H) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
</style><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><script src="https://cdn.bootcss.com/highlight.js/9.6.0/highlight.min.js" defer></script><script src="/js/paper.js" defer></script><script src="https://www.googletagmanager.com/gtag/js?id=xx-xxxxxxx-xx" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'xx-xxxxxxx-xx');</script><link rel="stylesheet" href="/css/tocbot.css"><script src="/js/tocbot.js" defer></script><script>window.addEventListener('DOMContentLoaded', () => {
  tocbot.init({
    // Where to render the table of contents.
    tocSelector: '.toc__content',
    // Where to grab the headings to build the table of contents.
    contentSelector: '.article__content',
    // Which headings to grab inside of the contentSelector element.
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    // For headings inside relative or absolute positioned containers within content.
    hasInnerContainers: true,
    orderedList: false,
    collapseDepth: 2,
  });
})</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
  }
});
MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
  }
});</script><link rel="preload" href="https://cdn.bootcss.com/highlight.js/9.6.0/styles/github.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.6.0/styles/github.min.css"><link rel="preload" href="https://fonts.googleapis.com/css?family=Abril+Fatface&amp;display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface&amp;display=swap"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="A-Grain-Of-Sands" type="application/atom+xml">
</head><body><div class="mask-border"></div><div class="head"><div class="head__inner"><h1><a href="/">A-Grain-Of-Sands</a></h1><p>a little site, a few techies</p></div></div><div class="paper-container"><div class="main"><div class="location-bar"><div class="line-1"><div class="horizontal-line" style="height: 3px"></div></div><div class="line-2"><div class="horizontal-line" style="height: 1px"></div></div><p class="text">五. 枚举与注解</p><div class="switch-button"><input class="container_toggle" type="checkbox" id="switch" name="mode"><label for="switch">Toggle</label></div><div class="line-3"><div class="horizontal-line" style="height: 1px"></div></div></div><div class="main__2-col"><article class="post-view__article"><div class="article__infomation"><div class="posts-item"><h2 class="posts-item__title"><a href="">五. 枚举与注解</a></h2><span class="post__date">2023-09-24</span><a href="/tags/Java/"><span class="post__tags">#Java</span></a><a href="/tags/Effective-Java/"><span class="post__tags">#Effective Java</span></a></div></div><div class="article__content"><p>Java 有两种特殊的类型：枚举和注解。本章讨论这两种类型的最佳实践。</p>
<h2 id="34-用-enum-代替-int-常量"><a href="#34-用-enum-代替-int-常量" class="headerlink" title="34. 用 enum 代替 int 常量"></a>34. 用 enum 代替 int 常量</h2><p>枚举类型指由一组固定的常量组成合法值的类型，比如九大行星、四季或扑克牌的花色等。在过去有两种常见的做法，即使用 int 常量或字符串常量来模拟枚举，如下所示。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> APPLE_FUJI = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> APPLE_PIPPIN = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> APPLE_GRANNY_SMITH = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure></p>
<p>使用 int 枚举模式有诸多缺点：</p>
<ul>
<li>不保证类型安全</li>
<li>没有描述性可言</li>
<li>没有命名空间（需要冗长的前缀）</li>
<li>发生修改后需要重新编译（更糟糕的是，不重新编译也能运行，但会导致错误的行为）</li>
<li>无法打印，难以调试</li>
<li>没有可靠的方式来遍历</li>
</ul>
<p>另一种做法则是使用 String 常量。实话说，虽然相对 int 常量来说好一些，但强得有限：</p>
<ul>
<li>可能导致用户硬编码字符串</li>
<li>可以直接使用错误的枚举而不发生编译错误（在运行时出错）</li>
<li>依赖于字符串比较操作，性能差</li>
</ul>
<p>现代的 Java 语言中提供了一种更好的方式，即使用枚举类型：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Apple</span> </span>&#123;FUJI, PIPPIN, GRANNY_SMITH&#125;<br></code></pre></td></tr></table></figure></p>
<p>Java 提供的枚举类型本质是枚举类的一个公有静态常量，由于不提供构造器，因此是真正的 final 类。枚举类型是严格受控的单例，没有任何办法进行扩展或是实例化。它具有编译期类型安全，传递任何错误的类型都会导致编译器报错。同时，由于它们彼此属于不同的枚举类，因此即使是同名常量也可以共处——每个类都有自己的命名空间。当然，通过添加 toString 方法，可以将其转换为具有可读性的字符串。此外，即使修改或添加枚举常量，也不需要重新编译客户端代码，因为有枚举类这一中间层存在。</p>
<h3 id="为枚举关联数据和行为"><a href="#为枚举关联数据和行为" class="headerlink" title="为枚举关联数据和行为"></a>为枚举关联数据和行为</h3><p>但是最重要的是，枚举类型可以添加任意的成员函数和字段，还能实现任意接口。这使得枚举类型异常强大。例如，我们可以实现一个行星枚举，每个行星都有自己的质量和半径，从而可以计算出它的表面重力：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Planet</span> </span>&#123;<br>    MERCURY(<span class="hljs-number">3.302e+23</span>, <span class="hljs-number">2.439e6</span>),<br>    VENUS  (<span class="hljs-number">4.869e+24</span>, <span class="hljs-number">6.052e6</span>),<br>    EARTH  (<span class="hljs-number">5.975e+24</span>, <span class="hljs-number">6.378e6</span>),<br>    MARS   (<span class="hljs-number">6.419e+23</span>, <span class="hljs-number">3.393e6</span>),<br>    JUPITER(<span class="hljs-number">1.899e+27</span>, <span class="hljs-number">7.149e7</span>),<br>    SATURN (<span class="hljs-number">5.685e+26</span>, <span class="hljs-number">6.027e7</span>),<br>    URANUS (<span class="hljs-number">8.683e+25</span>, <span class="hljs-number">2.556e7</span>),<br>    NEPTUNE(<span class="hljs-number">1.024e+26</span>, <span class="hljs-number">2.477e7</span>);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> mass;           <span class="hljs-comment">// In kilograms</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> radius;         <span class="hljs-comment">// In meters</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> surfaceGravity; <span class="hljs-comment">// In m / s^2</span><br><br>    <span class="hljs-comment">// Universal gravitational constant in m^3 / kg s^2</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> G = <span class="hljs-number">6.67300E-11</span>;<br><br>    <span class="hljs-comment">// Constructor</span><br>    Planet(<span class="hljs-keyword">double</span> mass, <span class="hljs-keyword">double</span> radius) &#123;<br>        <span class="hljs-keyword">this</span>.mass = mass;<br>        <span class="hljs-keyword">this</span>.radius = radius;<br>        surfaceGravity = G * mass / (radius * radius);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">mass</span><span class="hljs-params">()</span>           </span>&#123; <span class="hljs-keyword">return</span> mass; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">radius</span><span class="hljs-params">()</span>         </span>&#123; <span class="hljs-keyword">return</span> radius; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">surfaceGravity</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> surfaceGravity; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">surfaceWeight</span><span class="hljs-params">(<span class="hljs-keyword">double</span> mass)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mass * surfaceGravity;  <span class="hljs-comment">// F = ma</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>通过在枚举中声明字段并实现构造器，我们就能够轻松地把数据和枚举常量关联起来。由于枚举常量是不可变的，因此最好将所有字段也声明为 final 的。同时，每个枚举类型都有自带的<code>value()</code>方法，可以按声明顺序返回枚举值的数组。此外，<code>toString</code>默认返回它的声明名称。<code>Planet</code>枚举类可以轻松地打印出物体在各个行星上的质量：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeightTable</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-keyword">double</span> earthWeight = Double.parseDouble(args[<span class="hljs-number">0</span>]);<br>      <span class="hljs-keyword">double</span> mass = earthWeight / Planet.EARTH.surfaceGravity();<br>      <span class="hljs-keyword">for</span> (Planet p : Planet.values())<br>         System.out.printf(<span class="hljs-string">&quot;Weight on %s is %f%n&quot;</span>,<br>                 p, p.surfaceWeight(mass));<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>在2004年（即 Java 添加枚举的那年），冥王星依然是一颗大行星。如果你把一个元素从枚举中移除，会发生什么？对于没有引用该元素的客户端，什么也不会发生；对于引用了这个元素的客户端，如果它重新编译，会编译失败；否则会在运行到这一行时报错。差不多是你可以想到的最理想的行为。<br><code>Planet</code>类中展示了数据和枚举的关联；你还可以把行为和枚举关联起来。比如说，实现一个计算器：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Operation</span></span>&#123;<br>	PLUS, MINUS, TIMES, DIVIDE;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y)</span></span>&#123;<br>		<span class="hljs-keyword">switch</span>(<span class="hljs-keyword">this</span>)&#123;<br>			<span class="hljs-keyword">case</span> PLUS: <span class="hljs-keyword">return</span> x+y;<br>			<span class="hljs-keyword">case</span> MINUS: <span class="hljs-keyword">return</span> x-y;<br>			<span class="hljs-keyword">case</span> TIMES: <span class="hljs-keyword">return</span> x*y;<br>			<span class="hljs-keyword">case</span> DIVIDE: <span class="hljs-keyword">return</span> x/y;<br>		&#125;<br>		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionException(<span class="hljs-string">&quot;Unkown op:&quot;</span>+<span class="hljs-keyword">this</span>);	<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>虽然这段代码能用，但很丑。虽然 throw 语句执行不到，但必须添加。同时，如果你修改了枚举值却没有修改 switch 语句，依然能编译，但会在运行到修改后的枚举时出错。事实上，有更好的方法来实现行为与枚举的关联，那就是使用特定于常量的方法实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Operation</span> </span>&#123;<br>    PLUS(<span class="hljs-string">&quot;+&quot;</span>) &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> x + y; &#125;<br>    &#125;,<br>    MINUS(<span class="hljs-string">&quot;-&quot;</span>) &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> x - y; &#125;<br>    &#125;,<br>    TIMES(<span class="hljs-string">&quot;*&quot;</span>) &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> x * y; &#125;<br>    &#125;,<br>    DIVIDE(<span class="hljs-string">&quot;/&quot;</span>) &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> x / y; &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String symbol;<br><br>    Operation(String symbol) &#123; <span class="hljs-keyword">this</span>.symbol = symbol; &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> symbol; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">double</span> <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y)</span></span>;<br></code></pre></td></tr></table></figure></p>
<p>这一实现更加优雅；而且还能轻松地打印出算术表达式来：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 2.0000 + 4.0000 = 6.0000</span><br>System.out.printf(<span class="hljs-string">&quot;%f %s %f = %f%n&quot;</span>,x,op,y,op.apply(x,y));<br></code></pre></td></tr></table></figure></p>
<p>在上述的枚举中，我们覆盖了 toString 方法，这可能会导致在使用<code>valueOf()</code>方法时遇到一些问题（<code>valueOf</code>方法能够自动根据常量的名字获取枚举常量）。可以通过实现<code>fromString()</code>方法来将定制的字符串转变为相应的枚举。以下是一个通用的实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">// Implementing a fromString method on an enum type</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, Operation&gt; stringToEnum = Stream.of(values()).collect(toMap(Object::toString, e -&gt; e));<br><br> <span class="hljs-comment">// Returns Operation for string, if any</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Optional&lt;Operation&gt; <span class="hljs-title">fromString</span><span class="hljs-params">(String symbol)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> Optional.ofNullable(stringToEnum.get(symbol));<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>注意，我们返回了一个<code>Optional</code>类，以强迫客户端意识到传入的字符串不一定是有效的。</p>
<h3 id="使用策略枚举"><a href="#使用策略枚举" class="headerlink" title="使用策略枚举"></a>使用策略枚举</h3><p>特定于常量的方法实现有一个问题：那就是增加了在枚举常量中共享行为的难度。为了解释这一点，我们设计了一个枚举用来计算薪水，它的行为如下：</p>
<ul>
<li>如果是工作日，则8小时内计为正常工资，超过8小时的部分为加班工资；</li>
<li>如果是节假日，则所有时间都计为加班工资。</li>
</ul>
<p>可以想到的一种实现还是使用<code>switch</code>语句：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">PayrollDay</span> </span>&#123;<br>	MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MINS_PER_SHIFT = <span class="hljs-number">8</span>*<span class="hljs-number">60</span>;<br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pay</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minutesWorked, <span class="hljs-keyword">int</span> payRate)</span></span>&#123;<br>		<span class="hljs-keyword">int</span> basePay = minutesWorked * payRate;<br>		<span class="hljs-keyword">int</span> overtimePay = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">switch</span>(<span class="hljs-keyword">this</span>)&#123;<br>			<span class="hljs-keyword">case</span> SATURDAY: <span class="hljs-keyword">case</span> SUNDAY: overtimePay = basePay/<span class="hljs-number">2</span>;<br>				<span class="hljs-keyword">break</span>;<br>			<span class="hljs-keyword">default</span>: overtimePay = minutesWorked &lt;= MINS_PER_SHIFT ? <span class="hljs-number">0</span> : (minutesWorked - MINS_PER_SHIFT) * payRate / <span class="hljs-number">2</span>;<br>		&#125;<br>		<span class="hljs-keyword">return</span> basePay + overtimePay;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>这段代码其实非常危险。假设你后来又添加了一个新的元素，比如说表示节日，但忘记给<code>switch</code>语句添加相应的<code>case</code>，程序依然可以正常编译和运行，但却会悄悄地计算出错误的工资。但是，使用特定于常量的方法来计算工资也很麻烦，你需要为常量都添加大量雷同的代码，或是调用辅助方法，但依然会产生大量相似的代码，不仅降低了可读性，也增加了出错的概率。</p>
<p>我们实际上想要的是，每次添加新的枚举时，都<em>必须</em>选择一种工资计算策略。我们可以使用一种叫<strong>策略枚举</strong>的模式来实现。即，将计算工资移到一个私有的嵌套枚举中，并将工资计算委托给每个策略枚举中，如下如示：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">PayrollDay</span> </span>&#123;<br>    MONDAY(WEEKDAY), TUESDAY(WEEKDAY), WEDNESDAY(WEEKDAY),<br>    THURSDAY(WEEKDAY), FRIDAY(WEEKDAY),<br>    SATURDAY(WEEKEND), SUNDAY(WEEKEND);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PayType payType;<br><br>    PayrollDay(PayType payType) &#123; <span class="hljs-keyword">this</span>.payType = payType; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pay</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minutesWorked, <span class="hljs-keyword">int</span> payRate)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> payType.pay(minutesWorked, payRate);<br>    &#125;<br><br>    <span class="hljs-comment">// The strategy enum type</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">PayType</span> </span>&#123;<br>        WEEKDAY &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">overtimePay</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minsWorked, <span class="hljs-keyword">int</span> payRate)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> minsWorked &lt;= MINS_PER_SHIFT ? <span class="hljs-number">0</span> :<br>                        (minsWorked - MINS_PER_SHIFT) * payRate / <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;,<br>        WEEKEND &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">overtimePay</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minsWorked, <span class="hljs-keyword">int</span> payRate)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> minsWorked * payRate / <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">overtimePay</span><span class="hljs-params">(<span class="hljs-keyword">int</span> mins, <span class="hljs-keyword">int</span> payRate)</span></span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MINS_PER_SHIFT = <span class="hljs-number">8</span> * <span class="hljs-number">60</span>;<br><br>        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pay</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minsWorked, <span class="hljs-keyword">int</span> payRate)</span> </span>&#123;<br>            <span class="hljs-keyword">int</span> basePay = minsWorked * payRate;<br>            <span class="hljs-keyword">return</span> basePay + overtimePay(minsWorked, payRate);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>这种方法可能没有使用<code>switch</code>语句那么简洁，但更加安全，也更加灵活。不过，如果你需要给外部的枚举添加特定于枚举常量的行为，那就只能使用<code>switch</code>语句来实现。</p>
<p>什么时候应当使用枚举呢？当你需要一组固定常量，且其成员在编译期就已经确定时，就应当使用枚举。除了行星、星期、象棋的棋子外，菜单选项、操作代码和命令行参数也是合适的枚举类型。注意，枚举中的常量集并不一定会保持始终不变——使用枚举类型正是为了应对可能的变化。</p>
<h2 id="35-用成员变量代替序数"><a href="#35-用成员变量代替序数" class="headerlink" title="35. 用成员变量代替序数"></a>35. 用成员变量代替序数</h2><p>Java 中的枚举类型自带一个<code>ordinal</code>方法来返回每个枚举常量的数值。在许多和某个数值关联的枚举中，可以用这个方法来得到值。例如，以下是一个音乐组合的枚举：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Ensemble</span> </span>&#123;<br>    SOLO, DUET, TRIO, QUARTET, QUINTET, SEXTET, SEPTET, OCTET;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numberOfMusicians</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.ordinal() + <span class="hljs-number">1</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>你可能会觉得这个实现看起来还不错。大错特错。这个方法在后续维护时会要命。如果你需要添加一个和已有的值重复的枚举怎么办？比如说，双四重奏(double quarter)？这一组合也是由8个人组成，但已经有八重奏(OCTET)了，你没法添加。再比如说，如果你需要添加一个非连续的枚举，比如说三四重奏(triple quarter)，但并没有由11个人组成的集合，你只好多添加一个 dummy 常量。如果只是添加一个虚拟常量还好说，但你可能要添加几百上千个，那可完全不切实际。</p>
<p>正确的做法是把和枚举相关联的值保存在一个成员变量中：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Ensemble</span> </span>&#123;<br>    SOLO(<span class="hljs-number">1</span>), DUET(<span class="hljs-number">2</span>), TRIO(<span class="hljs-number">3</span>), QUARTET(<span class="hljs-number">4</span>), QUINTET(<span class="hljs-number">5</span>),<br>    SEXTET(<span class="hljs-number">6</span>), SEPTET(<span class="hljs-number">7</span>), OCTET(<span class="hljs-number">8</span>), DOUBLE_QUARTET(<span class="hljs-number">8</span>),<br>    NONET(<span class="hljs-number">9</span>), DECTET(<span class="hljs-number">10</span>), TRIPLE_QUARTET(<span class="hljs-number">12</span>);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> numberOfMusicians;<br>    Ensemble(<span class="hljs-keyword">int</span> size) &#123; <span class="hljs-keyword">this</span>.numberOfMusicians = size; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numberOfMusicians</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> numberOfMusicians; &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>事实上，Enum 规范中提到，<code>ordinal</code>方法是为了<code>EnumSet</code>这类基于枚举的通用集合类型而设计的。除非需要编写这类数据结构，否则应该避免使用<code>ordinal</code>方法。</p>
<h2 id="36-使用-EnumSet-代替位向量"><a href="#36-使用-EnumSet-代替位向量" class="headerlink" title="36. 使用 EnumSet 代替位向量"></a>36. 使用 EnumSet 代替位向量</h2><p>如果枚举元素需要用在集合中，常常会使用基于位向量的<code>int</code>枚举实现，比如说为每个枚举常量赋值为 2 的幂：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Text</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STYLE_BOLD = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STYLE_ITALIC = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STYLE_UNDERLINE = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STYLE_STRIKETHROUGH = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">applyStyles</span><span class="hljs-params">(<span class="hljs-keyword">int</span> style)</span> </span>&#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>这样的好处是可以用<code>OR</code>运算来将几个常量合并到一个集合中：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">text.applyStyles(STYLE_BOLD | STYLE_ITALIC);<br></code></pre></td></tr></table></figure></p>
<p>除此之外，还可以使用其他位操作，来高效地实现取交集或是补集这样的集合操作。不过位向量表示法具有<code>int</code>枚举常量的所有缺点，甚至更多：</p>
<ul>
<li>以数字形式打印的的位向量更加不具有可读性；</li>
<li>没有简单的方法来遍历位向量表示的所有枚举元素；</li>
<li>在编写 API 时，需要预测至多需要多少位。一旦确定好位向量的类型（比如<code>int</code>或是<code>long</code>，就不能超过其位宽）；</li>
</ul>
<p>有些人在需要传递枚举集合时，还是倾向于使用位向量。但没有这样做的理由，更好的替代方法是使用<code>EnumSet</code>类。它可以高效地表现单个枚举类型中的所有枚举值所组成的集合。它实现了<code>Set</code>接口，提供了丰富的功能、安全性和<code>Set</code>类的互操作性。在底层实现上，<code>EnumSet</code>使用位向量来实现。例如，如果对应枚举类型的枚举值数量少于 64 个，就会使用单个<code>long</code>来表示。同时，它的批量操作方法，比如<code>removeAll</code>和<code>retainAll</code>，也是使用位操作来实现的。这意味着它的性能和手工编写的位向量操作相差无几，但可以避免手工编写中的错误以及丑陋的代码。</p>
<p>下面是上述例子改成使用枚举实现后的代码，可以看到，它更加简短，更加清楚，也更加安全了：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Text</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Style</span></span>&#123;BOLD,ITALIC,UNDERLINE,STRIKETHROUGH&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">applyStyle</span><span class="hljs-params">(Set&lt;Style&gt; styles)</span></span>&#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>注意上述代码中<code>applyStyle</code>方法接收的类型是<code>Set</code>而非<code>EnumSet</code>。大部分时候还是接受接口类型而非实现类型为好，也方便某些特殊的客户端可能需要传递其他的<code>Set</code>实现。<code>EnumSet</code>提供了丰富的静态工厂方法，客户端如果要调用<code>applyStyle</code>方法会非常简单：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">text.applyStyles(EnumSet.of(Style.BOLD,Style.ITALIC));<br></code></pre></td></tr></table></figure></p>
<p><strong>正是由于枚举类型要用在集合中，所以没有理由非要用位向量来表示。</strong>使用<code>EnumSet</code>类吧，它既具有位向量的简洁和性能，又能充分发挥前述枚举类型的所有优点。</p>
<h2 id="37-使用-EnumMap-代替序数索引"><a href="#37-使用-EnumMap-代替序数索引" class="headerlink" title="37. 使用 EnumMap 代替序数索引"></a>37. 使用 EnumMap 代替序数索引</h2><p>如果需要用枚举作为索引来组织数组或<code>List</code>，你可能会利用<code>ordinal</code>方法来实现。比如说，用来表示一种用于烹饪的香草：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Plant</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">LifeCycle</span> </span>&#123;ANNUAL, PERENNIAL, BIENNIAL&#125;<br><br>    <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">final</span> LifeCycle lifeCycle;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Plant</span><span class="hljs-params">(String name, LifeCycle lifeCycle)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.lifeCycle = lifeCycle;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>假设现在有一个香草的数组，用来表示一座花园中的植物，需要按类型（一年生·多年生·两年生）来组织这些植物。这样一来需要构建三个集合，对应每种类型。然后还需要遍历花园，将每种香草放到对应的集合中，有些人会将这些集合放进一个以类型枚举的序数作为索引的数组中：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Set&lt;Plant&gt;[] plantsByLifeCycle = (Set&lt;Plant&gt;[]) <span class="hljs-keyword">new</span> Set[Plant.LifeCycle.values().length];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Plant.LifeCycle.values().length; i++)&#123;            <br>    plantsByLifeCycle[i]=<span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> p:garden)&#123;<br>    plantsByLifeCycle[p.lifeCycle.ordinal()].add(p);<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>这种方法隐藏着许多问题。数组不能与泛型兼容，因此程序需要进行未受检的转换，且不能保证编译一定正常。数组并不包含有关索引的信息，因此必须手工标注这些索引的输出。最大的问题在于，如果要访问这样一个由枚举序数所索引的数组时，必须始终保证使用了正确的索引<code>int</code>值（它并不能提供枚举的类型安全！）。如果使用了错误的值，程序也会偷偷完成错误的工作——运气好的话，可能会抛出<code>ArrayIndexOutOfBoundException</code>异常。</p>
<p>更好的方法是使用<code>Map</code>来实现枚举到值的映射。有一类专门设计的<code>Map</code>用于枚举键，即<code>EnumMap</code>类。以下就是用<code>EnumMap</code>改写的程序：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Map&lt;Plant.LifeCycle,Set&lt;Plant&gt;&gt; plantsByLifeCycle = <span class="hljs-keyword">new</span> EnumMap&lt;&gt;(Plant.LifeCycle.class);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> lifeCycle:Plant.LifeCycle.values())&#123;<br>    plantsByLifeCycle.put(lifeCycle, <span class="hljs-keyword">new</span> HashSet&lt;&gt;());<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> p:garden)&#123;<br>    plantsByLifeCycle.get(p.lifeCycle).add(p);<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>这段程序更简短、更清楚、也更安全，同时在运行速度上和使用枚举序数的数组相当。它没有不安全的转换；也不必手工标注映射的类型；而且计算数组索引时也不可能出错。<code>EnumMap</code>底层使用了类似于序数索引的数组，不过对外界隐藏了实现细节。此外，如果需要使用<code>stream</code>来生成这样一个<code>Map</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Arrays.stream(garden).collect(groupingBy(i -&gt; i.lifeCycle, toSet()));<br></code></pre></td></tr></table></figure></p>
<p>上述的形式不会生成一个<code>EnumMap</code>，因此时间复杂度的表现上并不会和枚举序数索引的数组相当。要解决这个问题，需要使用有三个参数的<code>Collectors.groupingBy</code>方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Arrays.stream(garden).collect(groupingBy(i -&gt; i.lifeCycle,()-&gt;<span class="hljs-keyword">new</span> EnumMap&lt;&gt;(Plant.LifeCycle.class) ,toSet()));<br></code></pre></td></tr></table></figure></p>
<p>在<code>Map</code>可能被大量调用的场合下，这样的优化是很有意义的。除此之外，基于<code>stream</code>的版本并不能保证为<code>LifeCycle</code>的每个枚举值都生成一个<code>Set</code>. 只有在花园里包含了对应类型（一年生·多年生·两年生）的植物时都会生成对应的<code>Set</code>，也就是说不会生成空的<code>Set</code>。这点可能需要注意。</p>
<p>在某些情况下可能存在按序数索引两次的二维数组，也就是从两个枚举映射到一个值。下述程序就是这样一个数组，它将两个阶段映射到一个变化（例如，液体到固体为凝固，液体到气体为沸腾）：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Phase</span> </span>&#123;<br>    SOLID, LIQUID, GAS<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Transition</span> </span>&#123;<br>    MELT, FREEZE, BOIL, CONDENSE, SUBLIME, DEPOSIT;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Transition[][] TRANSITIONS = &#123;<br>            &#123;<span class="hljs-keyword">null</span>, MELT, SUBLIME&#125;,<br>            &#123;FREEZE, <span class="hljs-keyword">null</span>, BOIL&#125;,<br>            &#123;DEPOSIT, CONDENSE, <span class="hljs-keyword">null</span>&#125;<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Transition <span class="hljs-title">from</span><span class="hljs-params">(Phase from, Phase to)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> TRANSITIONS[from.ordinal()][to.ordinal()];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>乍看之下，这个方法似乎还挺优雅的，但事情并非如此。首先，编译器并不知道索引和枚举之间的关系，这一关系必须由你维护。一旦过渡表的编写出了问题，或是在后续更新<code>Phase</code>以及<code>Transition</code>时忘了更新过渡表，就会出现难以出现的错误。可能是数据越界、空指针异常，或是更糟糕的，没有任何异常的错误行为。此外，表的大小将是阶数的平方，即使未来有更多<code>null</code>过渡也是如此。</p>
<p>使用<code>EnumMap</code>可以做得更好一些。阶段到过渡的映射关系实质上都是由两个有序的阶段枚举所指定的，因此可以首先指定过渡所关联的阶段。至于查询，可以通过一个二维的嵌套<code>Map</code>来指定，即<code>Map&lt;Phase,Map&lt;Phase, Transition&gt;&gt;</code>的形式。此后，只需要初始化该二维表：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Phase</span> </span>&#123;<br>    SOLID, LIQUID, GAS;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Transition</span> </span>&#123;<br>        MELT(SOLID, LIQUID), FREEZE(LIQUID, SOLID),<br>        BOIL(LIQUID, GAS), CONDENSE(GAS, LIQUID),<br>        SUBLIME(SOLID, GAS), DEPOSIT(GAS, SOLID);<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Phase from;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Phase to;<br><br>        Transition(Phase from, Phase to) &#123;<br>            <span class="hljs-keyword">this</span>.from = from;<br>            <span class="hljs-keyword">this</span>.to = to;<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Phase, Map&lt;Phase, Transition&gt;&gt; m =<br>                Stream.of(values()).collect(groupingBy(i -&gt; i.from,<br>                        () -&gt; <span class="hljs-keyword">new</span> EnumMap&lt;&gt;(Phase.class),<br>                        toMap(i -&gt; i.to, i -&gt; i, (x, y) -&gt; y, () -&gt; <span class="hljs-keyword">new</span> EnumMap&lt;&gt;(Phase.class))));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Transition <span class="hljs-title">from</span><span class="hljs-params">(Phase from, Phase to)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Transition.m.get(from).get(to);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>上述初始化过渡表的代码可能有些费解，使用了<code>Collectors</code>提供的的重叠工厂方法。使用显式迭代也许会更加烦琐，但的确更加易于理解。</p>
<p>现在假想要给系统添加一个新的阶段：电离（plasma）。与之相关的过渡状态只有两种，即电离化（ionization），即从气体到电离；以及消电离化（deionization），从电离到气体。如果要更新基于二维数组的程序，就需要扩充数组到 16 项，同时注意放置正确的过渡阶段（以及<code>null</code>！）。如果添加的元素数量不对，或是位置有偏差，程序依然可以编译通过，但在运行时会悄悄出错。而如果是基于<code>EnumMap</code>实现的，只需要将新增的阶段和过渡添加进枚举值里就行了。除此之外什么也不用做。几乎消除了所有出错的可能。从内部看，<code>EnumMap&lt;K, EnumMap&gt;&gt;</code>被实现为两个数组的嵌套，因此在提供了清晰性、可读性和安全性的同时，也没有增加额外的开销。</p>
<p>上述例子中使用<code>null</code>来表示不存在的过渡（如，状态没有变化时）。但这并非是一个良好的实践，运行时容易引发空指针异常。要为这个问题设计一个整洁、优雅的解决方案，可能需要细腻的考虑和充分探讨的设计，这和本篇的主旨已经无关了。</p>
<p>综上所述，在你想要使用枚举的序数来作为索引时，不妨使用<code>EnumMap</code>。在绝大多数情况下，你都不应当使用<code>ordinal()</code>方法。该方法只有在极特殊情况下都会被使用。</p>
<h2 id="38-用接口模拟可扩展的枚举"><a href="#38-用接口模拟可扩展的枚举" class="headerlink" title="38. 用接口模拟可扩展的枚举"></a>38. 用接口模拟可扩展的枚举</h2><p>几乎从所有方面上讲，使用枚举类型都优于使用类型安全的枚举模式。不过，有一点的确没有实现，那就是让一个枚举类去继承（扩展）另一个枚举类。Java 中的枚举类型是不可继承自其他类的，这其实是深思熟虑后的设计。历史证明，枚举的可扩展性绝大多数情况下都绝非好主意。子类型的枚举是父类型的实现，父亲类型的枚举却不是子类型的实例，这会导致极其混乱的情况。而且，也没有什么办法来遍历某一枚举类型及其所有子类型的所有枚举值。</p>
<p>但是的确存在需要扩展的枚举类型。有一个常用的例子，就是操作码，又称为 opcode. 操作码表示在某种机器上可以执行的操作，有时需要让 API 用户来提供自己的操作，以扩展 API 提供的操作集。幸运的是，有一种很好的方法可以利用枚举类型来实现这种效果，即通过将操作码类型定义为接口并为枚举类型实现对应接口。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">BasicOperation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Operation</span> </span>&#123;<br>    PLUS(<span class="hljs-string">&quot;+&quot;</span>) &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> x + y;<br>        &#125;<br>    &#125;,<br>    MINUS(<span class="hljs-string">&quot;-&quot;</span>) &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> x - y;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">final</span> String symbol;<br><br>    BasicOperation(String symbol) &#123;<br>        <span class="hljs-keyword">this</span>.symbol = symbol;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> symbol;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>虽然枚举类型<code>BasicOperation</code>是不可扩展的，但接口类型<code>Operation</code>是可扩展的，它可以用于表示 API 中操作的对象。如果需要，可以定义另一个枚举类型，它实现了<code>Operation</code>接口，并可以用于替代原有的枚举作为入参。例如，如果需要扩展上述操作枚举，比如增加求幂和求余去处，可以这样做：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ExtendedOperation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Operation</span> </span>&#123;<br>    EXP(<span class="hljs-string">&quot;^&quot;</span>) &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> Math.pow(x, y);<br>        &#125;<br>    &#125;,<br>    REMAINDER(<span class="hljs-string">&quot;%&quot;</span>) &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> x % y;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">final</span> String symbol;<br><br>    ExtendedOperation(String symbol) &#123;<br>        <span class="hljs-keyword">this</span>.symbol = symbol;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> symbol;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>现在，在任何可以使用基础操作枚举的地方，都可以使用新的操作枚举（当然，设计 API 是通过接口类型而非实现类型传参）。和 34 条不同的地方在于，不需要通过设计特定于实例的方法来声明抽象的<code>apply</code>方法，因为它是接口的一部分。</p>
<p>如果需要列举所有的枚举类型，可以通过传递枚举类名来使用它包含的所有操作。比如：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">double</span> x = Double.parseDouble(args[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">double</span> y = Double.parseDouble(args[<span class="hljs-number">1</span>]);<br>        test(ExtendedOperation.class, x, y);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T extends Enum&lt;T&gt; &amp; Operation&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Class&lt;T&gt; opEnumType, <span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (T op : opEnumType.getEnumConstants()) &#123;<br>            System.out.printf(<span class="hljs-string">&quot;%.2f %s %.2f = %.2f\n&quot;</span>, x, op, y, op.apply(x, y));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>上述程序中使用了递归的受限类型参数，以保证 Class 对象即表示枚举又实现了<code>Operation</code>接口，而这正是我们遍历元素和执行操作都需要的。</p>
<p>另一种方式是传入一个<code>Collection&lt;? extends Operation&gt;</code>，而非一个类名对象。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">double</span> x = Double.parseDouble(args[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">double</span> y = Double.parseDouble(args[<span class="hljs-number">1</span>]);<br>        test(Arrays.asList(ExtendedOperation.values()), x, y);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Collection&lt;? extends Operation&gt; opSet, <span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (Operation op : opSet) &#123;<br>            System.out.printf(<span class="hljs-string">&quot;%.2f %s %.2f = %.2f\n&quot;</span>, x, op, y, op.apply(x, y));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>这样得到的代码相对更易于理解，而且入参也比较灵活。它允许调用者传入多个不同实现的操作枚举。另一方面，也放弃了在指定操作上使用<code>EnumSet</code>或是<code>EnumMap</code>的机会。</p>
<p>运行上述程序可以得到结果：<br><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">4.00 ^ 7.00 = 16384.00<br>4.00 % 7.00 = 4.00<br></code></pre></td></tr></table></figure></p>
<p>不过，通过接口模拟可扩展的枚举有个小小的不足，就是不能将一个枚举类型的行为继承到另一个枚举类型上。如果实现代码本身不依赖于状态，可以把默认实现放在接口中。否则，就只能将需要复用的代码封装到一个辅助类（或静态辅助类）里，通过组合的方式来实现代码复用。本条目所述的模式在<code>java.nio.file.LinkOption</code>枚举中得到了应用。</p>
<p>总之，虽然不能编写可扩展的枚举类型，但可以通过编写接口以及实现该接口的基础枚举来对它进行模拟。同时，API 也应当根据接口进行编写。</p>
<h2 id="39-注解优先于命名模式"><a href="#39-注解优先于命名模式" class="headerlink" title="39. 注解优先于命名模式"></a>39. 注解优先于命名模式</h2><p>以往，工具或框架经常会使用命名模式<sup><a href="#fn_1" id="reffn_1">1</a></sup>来对特定的程序元素进行处理。例如，在 Java 4 以前，JUnit 框架要求所有测试方法必须以<code>test</code>开头。这种方法有几个缺点：</p>
<ol>
<li>拼写错误会导致没有任何提示的失败。例如，如果不小心拼写为了<code>tsetSafetyOverride</code>，JUnit 不会提示，但也不会执行测试，从而造成错误的安全感；</li>
<li>无法确定命名模式是否能应用于正确的程序元素上。如果不翻阅文档，使用者可能会错误地命名某个测试类为<code>TestSafetyMechanisms</code>并期望 JUnit 自动测试这个类中所有的方法。但是 JUnit 不会这样做，也不会给出提示；</li>
<li>参数值不能良好地和程序元素相关联。例如，你想要指定一个测试，它的预期状态是抛出某类特定的异常。异常类型就成为了测试的一个参数。但是要传递这一参数，如果采用命名模式就需要将异常名称关联或是编码到测试方法名中。这非常脆弱，而且也不雅观。编译器并不知道如果检验方法名中编码的异常名是否真的存在。如果该类并不存在，或者不是一个异常类，也需要直到运行时才能发现错误。</li>
</ol>
<h3 id="一个简单的注解"><a href="#一个简单的注解" class="headerlink" title="一个简单的注解"></a>一个简单的注解</h3><p>JUnit 4开始使用注解，很好地解决了以上问题。本条目中，我们将编写自己的测试框架原型来展示一下注解的用法。假设我们现在要定义一个注解类型来标记对应方法为测试方法，它们会自动运行，并在抛出异常时失败：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.annotation.*;<br><span class="hljs-meta">@Retention(PetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Test&#123;&#125;<br></code></pre></td></tr></table></figure></p>
<p><code>Test</code>注解类型声明上的注解被称为<strong>元注解</strong>。<code>@Retention(PetentionPolicy.RUNTIME)</code>注解表示，<code>Test</code>注解在运行期也依然存在（否则测试工具就不知道待运行的方法是否是测试方法）。而<code>@Target(ElementType.METHOD)</code>表明<code>Test</code>注解只能被应用到方法声明上：不能应用于类声明、作用域声明或是其他程序元素。</p>
<p>我们希望<code>Test</code>注解只能作用于无参静态方法，但没有实际施加这种限制。如果希望编译器为注解施加限制，必须编写一个注解处理器（annotation processor）来完成。</p>
<p>可以应用该注解到用于测试的方法上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span></span>&#123;<br>    <span class="hljs-meta">@Test</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-meta">@Test</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m3</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Boom&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m4</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-meta">@Test</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m5</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m6</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-meta">@Test</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m7</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Crash&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上述示例中有四个方法被标注为测试，其中一项会通过、两项会失败，另一项则不会被处理（因为我们的测试框架不会处理非静态方法）。另外三个方法则不会被执行。不过，<code>Test</code>注解不会改变<code>Sample</code>类的语义，它们只是提供了一些信息，为相关的其他程序使用。更一般地说，注解应当永远不会改变被注解代码的语义，但可以使它被其他工具更好地处理。有了<code>Test</code>注解，我们就可以编写对应的测试工具：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestRunner</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">int</span> tests = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> passed = <span class="hljs-number">0</span>;<br>        Class&lt;?&gt; testClazz = Class.forName(args[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (Method m : testClazz.getDeclaredMethods()) &#123;<br>            <span class="hljs-keyword">if</span> (m.isAnnotationPresent(Test.class)) &#123;<br>                tests++;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    m.invoke(<span class="hljs-keyword">null</span>);<br>                    passed++;<br>                &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;<br>                    System.out.println(e.getCause().toString());<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Invalid @Test:&quot;</span> + m);<br>                &#125;<br>            &#125;<br>        &#125;<br>        System.out.printf(<span class="hljs-string">&quot;Passed: %d, Failed: %d\n&quot;</span>, passed, tests - passed);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>上述测试运行工具通过命令行参数接收要执行测试的类名，并通过反射调用所有带有<code>Test</code>注解的方法。<code>isAnnotationPresent</code>方法告知该工具要运行哪些方法。如果被测试方法抛出异常，反射机制就会将它封装在<code>InvocationTargetException</code>中。该工具捕捉这个异常，并打印失败报告，包含测试方法抛出的原始异常。</p>
<p>如果尝试通过反射调用测试方法时抛出<code>InvocationTargetException</code>之外的任何异常，表明编译时没有捕捉到<code>Test</code>的无效用法（比如注解在实例方法上、注解方法带有参数或者不可访问）。测试工具中的第二个<code>catch</code>块捕捉到被注解的方法运行时抛出的其他异常，并将相应的错误信息打印出来。</p>
<h3 id="为注解增加参数"><a href="#为注解增加参数" class="headerlink" title="为注解增加参数"></a>为注解增加参数</h3><p>现在我们需要针对只有在抛出指定异常时才视作成功的测试添加支持，为此可以新增一个注解类型：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ExceptionTest &#123;<br>    Class&lt;? extends Throwable&gt; value();<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>这个注解的参数类型是<code>Class&lt;? extends Throwable&gt;</code>，即任意拓展了<code>Throwable</code>的类的<code>Class</code>对象，用于注解的使用者指定任意异常类型。下面就是一个可行的用例：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sample2</span> </span>&#123;<br>    <span class="hljs-meta">@ExceptionTest(ArithmeticException.class)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        i = <span class="hljs-number">1</span> / i;<br>    &#125;<br><br>    <span class="hljs-meta">@ExceptionTest(ArithmeticException.class)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> i = a[<span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-meta">@ExceptionTest(ArithmeticException.class)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m3</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>现在我们还需要修改一下测试工具来处理新的注解，只需要将以下代码添加到<code>main</code>方法中：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (m.isAnnotationPresent(ExceptionTest.class)) &#123;<br>	tests++;<br>    <span class="hljs-keyword">try</span> &#123;<br>		m.invoke(<span class="hljs-keyword">null</span>);<br>	&#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;<br>		Throwable exec = e.getCause();<br>		<span class="hljs-keyword">var</span> execType = m.getAnnotation(ExceptionTest.Class).value();<br>		<span class="hljs-keyword">if</span>(execType.isInstance(exec))&#123;<br>			passed++;		<br>		&#125;<span class="hljs-keyword">else</span>&#123;<br>			System.out.printf(<span class="hljs-string">&quot;Test %s failed: expected %s, got%s\n&quot;</span>,m,execType.getName(),exec);<br>		&#125;<br>	&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>		System.out.println(<span class="hljs-string">&quot;Invalid @Test:&quot;</span> + m);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>这段代码和之前相比，提取了注解参数的值，并用它来检验该测试抛出的异常是否为正确的类型。没有显式的转换，因此杜绝了<code>ClassCastException</code>的危险。编译过的测试程序确保其注解参数表示的是有效的异常类型。除非：注解参数在编译时是有效的，但对应的异常类型的类文件在运行时却不存在。在这种极少出现的情况下，程序可能会抛出<code>TypeNotPresentException</code>异常。</p>
<h3 id="从注解中获取多个参数"><a href="#从注解中获取多个参数" class="headerlink" title="从注解中获取多个参数"></a>从注解中获取多个参数</h3><p>如果继续深入一下，希望测试在抛出任何多种指定异常中的任意一种时都能测试通过，可以使用下述用法来支持：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ExceptionTest &#123;<br>    Class&lt;? extends Throwable&gt;[] value(); <span class="hljs-comment">// array is enough!</span><br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>注解中的数组参数十分灵活。即使修改为数组参数，原有的所有<code>ExceptionTest</code>注解依然有效，并会被生成为一个包含单个元素的数组。如果需要指定多个元素，使用花括号包裹并用逗号隔开：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ExceptionTest(&#123;IndexOutOfBoundsException.class, NullPointerException.class&#125;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    list.addAll(<span class="hljs-number">5</span>, <span class="hljs-keyword">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>测试工具的修改也非常简单，只需要修改为：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> oldPassed = passed;<br><span class="hljs-keyword">var</span> execTypes = m.getAnnotation(ExceptionTest.Class).value();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> execType: execTypes)&#123;<br>	<span class="hljs-keyword">if</span>(execType.isInstance(exec))&#123;<br>		passed++;<br>		<span class="hljs-keyword">break</span>;		<br>	&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(oldPassed == passed)&#123;<br>	System.out.printf(<span class="hljs-string">&quot;Test %s failed: expected %s, got%s\n&quot;</span>,m,Arrays.toString(execTypes),exec);<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>从 Java 8 开始，还有另一种方式可以进行多值注解，就是用<code>@Repeatale</code>元注解。它的参数是一个包含注解类型的注解容器类对象，其<code>value</code>属性必须为一个当前被注解的注解类型的数组。使用<code>@Repeatale</code>修改后的版本如下所示，注意包含数组的注解容器类型也必须有正确的注解策略和注解目标，否则无法编译通过：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Repeatable(ExceptionTestContainer.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ExceptionTest &#123;<br>    Class&lt;? extends Throwable&gt; value();<br>&#125;<br><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@interface</span> ExceptionTestContainer &#123;<br>    ExceptionTest[] value();<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>这样一来要使用<code>ExceptionTest</code>的测试方法可以写为：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ExceptionTest(IndexOutOfBoundsException.class)</span><br><span class="hljs-meta">@ExceptionTest(NullPointerException.class)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    list.addAll(<span class="hljs-number">5</span>, <span class="hljs-keyword">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>可重复的注解实际上会生成一个包含注解类型的合成注解。使用<code>getAnnotationByType</code>可以访问可重复注解类型的重复和非重复的注解，但使用<code>isAnnotationPresent</code>则指明了重复的注解并不是注解类型的一部分（实际上，它是注解容器类型）。使用<code>isAnnotationPresent</code>方法检查某个程序元素是否具有指定的注解，可能会默默忽略掉重复的注解；使用它检查是否存在包含的注解，可能又会忽略到非重复的注解。因此，需要同时检查注解类型和注解容器类型：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(m.isAnnotationPresent(ExceptionTest.class)||m.isAnnotationPresent(ExceptionTestContainer.class))&#123;<span class="hljs-comment">/*...*/</span>&#125;<br></code></pre></td></tr></table></figure></p>
<p>使用可重复的注解可能可以提升源代码的可读性，本质上是将一个注解的多个实例应用到同一个程序元素上。如果你觉得它能增加可读性，就使用它，但要需要在处理时增加更多的模板代码，而且增加了出错的可能性。</p>
<p>如果你在写一个需要程序员为源代码增加额外信息的工具，就可能得定义一组合适的注解类型。<strong>有了注解，就没有任何必要使用命名模式了</strong>。不过，除了工具铁匠<sup><a href="#fn_2" id="reffn_2">2</a></sup>之外，其他程序员应该都不会需要自己定义注解类型。但是，你依然应当使用 Java 平台所预定义的注解类型，并考虑使用 IDE 或其他静态分析工具提供的预定义注解，以提升这些工具提供的诊断信息的质量。</p>
<h2 id="40-坚持使用-Override-注解"><a href="#40-坚持使用-Override-注解" class="headerlink" title="40. 坚持使用 Override 注解"></a>40. 坚持使用 Override 注解</h2><p>在 Java 类库提供的注解中，最为重要的应该是<code>@Override</code>注解。它只能用在方法声明中，表示被注解的方法覆盖了超类中的某个方法。使用这一注解可以有效地避免许多常见的错误。且看这个示例：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> io.gloryalex.bulletinboard.utils;<br><br><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.Objects;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bigram</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> first;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> second;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Bigram</span><span class="hljs-params">(<span class="hljs-keyword">char</span> first, <span class="hljs-keyword">char</span> second)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>        <span class="hljs-keyword">this</span>.second = second;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Bigram o)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> first == o.first &amp;&amp; second == o.second;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(first, second);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Set&lt;BigRam&gt; s = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>; c++) &#123;<br>                s.add(<span class="hljs-keyword">new</span> Bigram(c, c));<br>            &#125;<br>        &#125;<br>        System.out.println(s.size());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>在上述例子中，我们的程序反复地将26个双字母组合增加到<code>Set</code>中，并在最后打印出<code>Set</code>的大小。结果理应是26，但打印出的却是260. 这是为什么呢？</p>
<p>仔细分析程序可以发现，<code>Bigram</code>类的作者原本想要覆盖<code>hashCode</code>和<code>equals</code>方法，但却错误地<em>重载</em>了该方法。如果要覆盖<code>Object.hashCode()</code>方法，需要定义一个参数为<code>Object</code>的<code>equals</code>方法。因此，在<code>Set</code>中使用<code>Bigram</code>时，依然调用的是<code>Object.hashCode()</code>，即比较对象的同一性（相当于使用<code>==</code>运算符）。这就是程序会打印出260的原因。</p>
<p>如果在一开始就使用<code>@Override</code>明确表示要覆盖<code>equals</code>方法，那么程序会在编译时报错：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&gt; Bigram.java:<span class="hljs-number">16</span>:<span class="hljs-number">5</span><br>java: 方法不会覆盖或实现超类型的方法<br></code></pre></td></tr></table></figure></p>
<p>也许你就会立刻恍然大悟，并修改为正确的实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> BigRam b) &#123;<br>        <span class="hljs-keyword">return</span> first == b.first &amp;&amp; second == b.second;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>因此，<strong>在所有想要覆盖父类或接口声明的每个方法声明上都使用 Override 注解</strong>。当然，如果你的类继承自抽象类或没有默认方法实现的接口，不使用<code>@Override</code>会导致编译不能通过。但是即使是这种情况下，也可以使用<code>@Override</code>来明确指明该方法是一个抽象方法的实现。大多数 IDE 都能在你需要覆盖一个方法时自动插入<code>@Override</code>注解。此外，在 IDE 中，如果覆盖了父类方法却没有使用<code>@Override</code>注解，通常 IDE 会产生一条警告，以保证你没有覆盖任何不想要覆盖的方法。</p>
<p>对于抽象类或是接口的继承，也还是值得标注所有你想要覆盖的方法，无论其是抽象的还是具体的。使用，<code>Set</code>接口并没有给<code>Collection</code>接口添加任何新方法，所以它在所有方法声明上都加上了<code>@Override</code>注解，以保证没有意外地添加新的方法。</p>
<h2 id="41-用标记接口定义类型"><a href="#41-用标记接口定义类型" class="headerlink" title="41. 用标记接口定义类型"></a>41. 用标记接口定义类型</h2><p>标记接口是指不包含任何方法的接口。它们的作用是指明一个类具有某种属性。例如，对于<code>Serialization</code>接口，实现该接口的类可以被写入到<code>ObjectOutputStream</code>中。<br>有人说标记注解使标记接口过时了，不过这种断言并不正确。标记接口有两个优点：</p>
<h3 id="标记接口定义的类型是由被标记类的实例实现的"><a href="#标记接口定义的类型是由被标记类的实例实现的" class="headerlink" title="标记接口定义的类型是由被标记类的实例实现的"></a>标记接口定义的类型是由被标记类的实例实现的</h3><p>标记接口是一个类型，这样就能保证错误在编译期就能发现。例如，如果使用<code>ObjectOutputStream.writeObject</code>方法，而传入的类并没有使用<code>Serialization</code>接口标记，那么编译就不能通过。不过遗憾的是<code>ObjectOutputStream.write</code>的入参是<code>Object</code>，所以如果传入不可序列化的类，将直到运行时才会发现问题。</p>
<h3 id="标记接口更加精确"><a href="#标记接口更加精确" class="headerlink" title="标记接口更加精确"></a>标记接口更加精确</h3><p>如果注解类型用<code>ElementType.TYPE</code>声明，那么它可以被应用于任何类或接口。但如果某个标记仅用于特定的接口，就可以把它唯一的接口拓展为适合它的接口，从而确保所有被标记的类都是该接口的子类型。</p>
<p>比如说，对于<code>Set</code>接口，其实它在<code>Collection</code>接口上的基础上并没有增加任何新的方法。但它描述了整体对象的某种约束条件。此外，标记接口也可以表明实例可以被其他某些类进行处理。（当然，<code>Set</code>接口改进了几个<code>Collection</code>方法的约束，所以一般不被视为标记类型）。</p>
<p>标记注解的主要优点在于：</p>
<h3 id="标记注解是更大的注解机制的一部分"><a href="#标记注解是更大的注解机制的一部分" class="headerlink" title="标记注解是更大的注解机制的一部分"></a>标记注解是更大的注解机制的一部分</h3><p>如果你在使用某些支持注解的框架，优先使用标记注解更能保持一致性。</p>
<p>因此，如果标记应用于任何程序元素、或是作为某个框架的注解体系的一部分，应当使用标记注解；如果标记仅应用于某些类或接口，就应当优先使用标记接口，以获得编译期检查的好处。总之，二者皆有好处。</p>
<p>如果不想定义类型就不要使用接口；相反的，如果想要定义类型，优先使用接口。</p>
<hr>
<blockquote id="fn_1">
<sup>1</sup>.    naming pattern<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>.    toolsmith，平台框架程序员<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
</div></article><div class="post-view__sidebar"><div class="sidebar"><div class="tocbot"><h2>Toc</h2><div class="toc__content"></div></div><h2>Links</h2><div class="sidebar__link"><ul><li><a target="_blank" rel="noopener" href="https://github.com/gloryalex">Github</a></li><li><a href="mailto:gloryxie@icloud.com">Mail</a></li><li><a href="/atom.xml">Rss</a></li></ul></div><h2>Archives</h2><div class="sidebar__archives"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/">2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a></li></ul></div><h2>Categories</h2><div class="sidebar__categories"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%88%E7%8E%87/">效率</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%90%86%E8%B4%A2/">理财</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></li></ul></div><h2>Tags</h2><div class="sidebar__tags"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AppleScript/" rel="tag">AppleScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Effective-Java/" rel="tag">Effective Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EffectiveJava/" rel="tag">EffectiveJava</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HeadFirstServlet/" rel="tag">HeadFirstServlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaWeb/" rel="tag">JavaWeb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MapReduce/" rel="tag">MapReduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Raft/" rel="tag">Raft</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RegExp/" rel="tag">RegExp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Servlet/" rel="tag">Servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%84%9A%E6%9C%AC/" rel="tag">脚本</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/" rel="tag">自我提升</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%B0%E5%B8%90/" rel="tag">记帐</a></li></ul></div></div></div></div><div class="horizontal-line" style="height: 1px"></div><div class="main__bottom"><div class="pre-next"><a class="pre-button">没有更多</a><a class="next-button" href="/2023/03/12/AppleScript%E5%B0%8F%E7%BB%93/">AppleScript 基本语法</a></div></div></div></div><div class="footer"><span>©️2019-2023 Designed By&nbsp;<strong><a target="_blank" rel="noopener" href="https://github.com/random-yang">RandomYang</a></strong> Powered By&nbsp;</span><strong><a target="_blank" rel="noopener" href="https://hexo.io">hexo</a></strong></div><div class="darkmode-mask" id="darkmode-mask"></div><div class="sidebar__button"></div></body></html>